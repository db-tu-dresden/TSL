---
name: "compare"
description: "Compare primitives."
...
---
primitive_name: "equal"
brief_description: "Compares two vector registers for equality."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "vec_a"
    description: "Left vector."
  - ctype: "const typename Vec::register_type"
    name: "vec_b"
    description: "Right vector."
returns:
  ctype: "typename Vec::mask_type"
  description: "Vector mask type indicating whether vec_a[*]==vec_b[*]."
testing: #optional
  - test_name: "all_equal"
    requires: ["to_integral", "loadu"]
    includes: ["<cstddef>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 1, false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
        reference_result_ptr[0] = Vec::vector_element_count();
        auto vec1 = loadu<Vec>( &test_data_ptr[i] );
        auto vec2 = loadu<Vec>( &test_data_ptr[i] );
        auto result_mask = equal<Vec>( vec1, vec2 );
        auto result_integral = to_integral<Vec>( result_mask );
        size_t matches = 0;
        for ( size_t i = 0; i < Vec::vector_element_count(); ++i ) {
          if(((result_integral >> i) & 0b1) == 1 ) {
            matches += 1;
          }
        }
        test_result_ptr[0] = matches;
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
  - test_name: "none_equal"
    requires: ["to_integral", "loadu"]
    includes: ["<cstddef>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 1, false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      auto vec1 = set1<Vec>( -1 );
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
        reference_result_ptr[0] = 0;
        auto vec2 = loadu<Vec>( &test_data_ptr[i] );
        auto result_mask = equal<Vec>( vec1, vec2 );
        auto result_integral = to_integral<Vec>( result_mask );
        size_t matches = 0;
        for ( size_t i = 0; i < Vec::vector_element_count(); ++i ) {
          if(((result_integral >> i) & 0b1) == 1 ) {
            matches += 1;
          }
        }
        test_result_ptr[0] = matches;
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ['avx512bw']
    specialization_comment: "Signed comparison."
    implementation: "return _mm512_cmpeq_epi{{ intrin_tp[ctype][1] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx512f']
    specialization_comment: "Signed comparison."
    implementation: "return _mm512_cmpeq_epi{{ intrin_tp[ctype][1] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_cmpeq_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
#todo: Implement 128/256 bit variants.
#todo: Conceptional challenge: simd<T, avx512, 256> as Processingstyle would require all primitives to have a related definition... Maybe implement a cast?
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx2']
    specialization_comment: "Signed comparison."
    implementation: "return _mm256_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b);"
  - target_extension: "avx2"
    ctype: ["float"]
    lscpu_flags: ['avx', 'avx2']
    specialization_comment: "Signed comparison."
    is_native: False
    implementation: "return _mm256_castsi256_ps(_mm256_cmpeq_epi32(_mm256_castps_si256(vec_a), _mm256_castps_si256(vec_b)));"
  - target_extension: "avx2"
    ctype: ["double"]
    lscpu_flags: ['avx', 'avx2']
    specialization_comment: "Signed comparison."
    is_native: False
    implementation: "return _mm256_castsi256_pd(_mm256_cmpeq_epi64(_mm256_castpd_si256(vec_a), _mm256_castpd_si256(vec_b)));"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t"]
    lscpu_flags: ['sse2']
    implementation: "return _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b);"
  - target_extension: "sse"
    ctype: ["int64_t", "uint64_t"]
    lscpu_flags: ['sse4_1']
    specialization_comment: "Signed comparison."
    implementation: "return _mm_cmpeq_epi64(vec_a,vec_b);"
  - target_extension: ["sse"]
    ctype: ["float"]
    lscpu_flags: ["sse"]
    implementation: "return _mm_cmpeq_ps(vec_a, vec_b);"
  - target_extension: ["sse"]
    ctype: ["double"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_cmpeq_pd(vec_a, vec_b);"
#ARM - NEON
  - target_extension: "neon"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['neon']
    implementation: "return vceqq_{{ intrin_tp_full[ctype] }}(vec_a, vec_b);"
#SCALAR
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return (vec_a == vec_b);"
#INTEL - FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      using T = typename Vec::register_type;
      T result{};
      // Create a value with all bits set to 1, regardless of underlying type
      {% if ctype in ["float", "double"] %}
      typename Vec::base_type checker;
      memset((void*)&checker, 0xff, sizeof(checker));
      {% else %}
      typename Vec::base_type checker = ~0;
      {% endif %}
      //
      TSL_UNROLL(Vec::vector_element_count())
      for(size_t i = 0; i < Vec::vector_element_count(); ++i) {
        result[i] = (vec_a[i] == vec_b[i]) ? checker : 0;
      }
      return result;
...
---
primitive_name: "equal"
functor_name: "mask_equal"
brief_description: "Compares two vector registers for equality."
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "mask"
    description: "Mask, indicating which lanes should be checked for equality"
  - ctype: "const typename Vec::register_type"
    name: "vec_a"
    description: "Left vector."
  - ctype: "const typename Vec::register_type"
    name: "vec_b"
    description: "Right vector."
returns:
  ctype: "typename Vec::mask_type"
  description: "Vector mask type indicating whether vec_a[*]==vec_b[*]."
testing: #optional
  - test_name: "all_equal"
    requires: ["to_integral", "loadu"]
    includes: ["<cstddef>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 1, false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
        reference_result_ptr[0] = Vec::vector_element_count();
        auto vec1 = loadu<Vec>( &test_data_ptr[i] );
        auto vec2 = loadu<Vec>( &test_data_ptr[i] );
        auto result_mask = equal<Vec>( vec1, vec2 );
        auto result_integral = to_integral<Vec>( result_mask );
        size_t matches = 0;
        for ( size_t i = 0; i < Vec::vector_element_count(); ++i ) {
          if(((result_integral >> i) & 0b1) == 1 ) {
            matches += 1;
          }
        }
        test_result_ptr[0] = matches;
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
  - test_name: "all_unequal"
    requires: ["to_integral", "loadu"]
    includes: ["<cstddef>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 1, false, testing::seq_init<T>,1};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - (1+Vec::vector_element_count()); i+=Vec::vector_element_count()) {
        *reference_result_ptr = 0;
        auto vec1 = loadu<Vec>( &test_data_ptr[i] );
        auto vec2 = loadu<Vec>( &test_data_ptr[i+1] );
        auto result_mask = equal<Vec>( vec1, vec2 );
        auto result_integral = to_integral<Vec>( result_mask );
        size_t matches = 0;
        for ( size_t i = 0; i < Vec::vector_element_count(); ++i ) {
          if(((result_integral >> i) & 0b1) == 1) {
            matches += 1;
          }
        }
        *test_result_ptr = matches;
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['avx512f']
    specialization_comment: "Signed comparison."
    implementation: "return mask & functors::equal<Vec, Idof>::apply(vec_a, vec_b);"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['avx2']
    specialization_comment: "Signed comparison."
    implementation: "return _mm256_and_si256(functors::equal<Vec, Idof>::apply(vec_a, vec_b), mask);"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['sse2']
    specialization_comment: "Signed comparison."
    implementation: "return _mm_and_si128(functors::equal<Vec, Idof>::apply(vec_a, vec_b), mask);"
  #Scalar
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return (vec_a == vec_b) & mask;"
...
---
primitive_name: "equal"
functor_name: "equal_masks"
brief_description: "Compares two imasks for equality."
parameters:
  - ctype: "const typename Vec::imask_type"
    name: "mask_a"
    description: "Left vector."
  - ctype: "const typename Vec::imask_type"
    name: "mask_b"
    description: "Right vector."
returns:
  ctype: "bool"
  description: "bool indicating whether mask_a[*]==mask_b[*]."
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['avx512f']
    implementation: "return mask_a == mask_b;"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['avx2']
    implementation: "return mask_a == mask_b;"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['sse']
    implementation: "return mask_a == mask_b;"
  #Scalar
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return mask_a == mask_b;"
...
---
primitive_name: "nequal"
brief_description: "Compares two vector registers for inequality."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "vec_a"
    description: "Left vector."
  - ctype: "const typename Vec::register_type"
    name: "vec_b"
    description: "Right vector."
returns:
  ctype: "typename Vec::mask_type"
  description: "Vector mask type indicating whether vec_a[*]!=vec_b[*]."
testing:
  - test_name: "all_equal"
    requires: ["to_integral", "loadu"]
    includes: ["<cstddef>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 1, false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
        *reference_result_ptr = 0;
        auto vec1 = loadu<Vec>( &test_data_ptr[i] );
        auto vec2 = loadu<Vec>( &test_data_ptr[i] );
        auto result_mask = equal<Vec>( vec1, vec2 );
        auto result_integral = to_integral<Vec>( result_mask );
        size_t matches = 0;
        for ( size_t i = 0; i < Vec::vector_element_count(); ++i ) {
          if(!(((result_integral >> i) & 0b1) == 1) ) {
            matches += 1;
          }
        }
        *test_result_ptr = matches;
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
  - test_name: "all_unequal"
    requires: ["to_integral", "loadu"]
    includes: ["<cstddef>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 1, false, testing::seq_init<T>,1};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - (1+Vec::vector_element_count()); i+=Vec::vector_element_count()) {
        *reference_result_ptr = Vec::vector_element_count();
        auto vec1 = loadu<Vec>( &test_data_ptr[i] );
        auto vec2 = loadu<Vec>( &test_data_ptr[i+1] );
        auto result_mask = equal<Vec>( vec1, vec2 );
        auto result_integral = to_integral<Vec>( result_mask );
        size_t matches = 0;
        for ( size_t i = 0; i < Vec::vector_element_count(); ++i ) {
          if(!(((result_integral >> i) & 0b1) == 1)) {
            matches += 1;
          }
        }
        *test_result_ptr = matches;
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ['avx512bw']
    specialization_comment: "Signed comparison."
    implementation: "return _mm512_cmpneq_epi{{ intrin_tp[ctype][1] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx512f']
    specialization_comment: "Signed comparison."
    implementation: "return _mm512_cmpneq_epi{{ intrin_tp[ctype][1] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_cmpneq_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  #todo: Implement 128/256 bit variants.
  #todo: Conceptional challenge: simd<T, avx512, 256> as Processingstyle would require all primitives to have a related definition... Maybe implement a cast?
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx2']
    is_native: False
    implementation: |
      auto const all_set = _mm256_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a,vec_a);
      return _mm256_andnot_si256(_mm256_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b), all_set);
  - target_extension: "avx2"
    ctype: ["float"]
    lscpu_flags: ['avx', 'avx2']
    specialization_comment: "Signed comparison."
    is_native: False
    implementation: |
      auto const all_set = _mm256_cmpeq_epi32(_mm256_castps_si256(vec_a),_mm256_castps_si256(vec_a));
      return _mm256_castsi256_ps(_mm256_andnot_si256(_mm256_cmpeq_epi32(_mm256_castps_si256(vec_a), _mm256_castps_si256(vec_b)), all_set));
  - target_extension: "avx2"
    ctype: ["double"]
    lscpu_flags: ['avx', 'avx2']
    specialization_comment: "Signed comparison."
    is_native: False
    implementation: |
      auto const all_set = _mm256_cmpeq_epi64(_mm256_castpd_si256(vec_a),_mm256_castpd_si256(vec_a));
      return
        _mm256_castsi256_pd(
          _mm256_andnot_si256(
            _mm256_cmpeq_epi64(
              _mm256_castpd_si256(vec_a),
              _mm256_castpd_si256(vec_b)
            ),
            all_set
          )
        );
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t"]
    lscpu_flags: ['sse2']
    implementation: |
      auto const all_set = _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a,vec_a);
      return _mm_andnot_si128(_mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b), all_set);
  - target_extension: "sse"
    ctype: ["int64_t", "uint64_t"]
    lscpu_flags: ['sse4_1']
    implementation: |
      auto const all_set = _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a,vec_a);
      return _mm_andnot_si128(_mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b), all_set);
  #SCALAR
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return (vec_a != vec_b);"
  #INTEL - FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      using T = typename Vec::register_type;
      T result{};
      // Create a value with all bits set to 1, regardless of underlying type
      {% if ctype in ["float", "double"] %}
      typename Vec::base_type checker;
      memset((void*)&checker, 0xff, sizeof(checker));
      {% else %}
      typename Vec::base_type checker = ~0;
      {% endif %}
      //
      TSL_UNROLL(Vec::vector_element_count())
      for(size_t i = 0; i < Vec::vector_element_count(); ++i) {
        result[i] = (vec_a[i] == vec_b[i]) ? 0 : checker;
      }
      return result;
...
---
primitive_name: "equal_as_imask"
brief_description: "Compares two registers for equality and returns an integral mask."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "vec_a"
    description: "Left vector."
  - ctype: "const typename Vec::register_type"
    name: "vec_b"
    description: "Right vector."
returns:
  ctype: "typename Vec::imask_type"
  description: "Integral mask indicating whether vec_a[*]==vec_b[*]."
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['avx512f']
    implementation: "return functors::equal<Vec, Idof>::apply(vec_a, vec_b);"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['avx2']
    requires: ["to_integral"]
    implementation: "return functors::to_integral<Vec, Idof>::apply(functors::equal<Vec, Idof>::apply(vec_a, vec_b));"
  - target_extension: "avx2"
    ctype: ["int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["avx2", "avx512f", "avx512vl"]
    implementation: "return _mm256_cmpeq_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ["avx2", "avx512f", "avx512vl", "avx512bw"]
    implementation: "return _mm256_cmpeq_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx2", "avx512f", "avx512vl"]
    implementation: "return _mm256_cmp_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b, _CMP_EQ_OQ);"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['sse2']
    requires: ["to_integral"]
    implementation: "return functors::to_integral<Vec, Idof>::apply(functors::equal<Vec, Idof>::apply(vec_a, vec_b));"
  - target_extension: "sse"
    ctype: ["int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ["sse", "avx512f", "avx512vl"]
    implementation: "return _mm_cmpeq_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ["sse", "avx512f", "avx512vl", "avx512bw"]
    implementation: "return _mm_cmpeq_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "sse"
    ctype: ["float", "double"]
    lscpu_flags: ["sse", "avx512f", "avx512vl"]
    implementation: "return _mm_cmp_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b, _CMP_EQ_OQ);"
  #Scalar
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    requires: ["to_integral"]
    implementation: "return functors::to_integral<Vec, Idof>::apply(functors::equal<Vec, Idof>::apply(vec_a, vec_b));"
...
---
primitive_name: "nequal"
functor_name: "nequal_masks"
brief_description: "Compares two imasks for non-equality."
parameters:
  - ctype: "const typename Vec::imask_type"
    name: "mask_a"
    description: "Left vector."
  - ctype: "const typename Vec::imask_type"
    name: "mask_b"
    description: "Right vector."
returns:
  ctype: "bool"
  description: "bool indicating whether mask_a[*]==mask_b[*]."
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['avx512f']
    implementation: "return mask_a != mask_b;"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['avx2']
    implementation: "return mask_a != mask_b;"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['sse']
    implementation: "return mask_a != mask_b;"
  #Scalar
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return mask_a != mask_b;"
...
---
primitive_name: "less_than"
brief_description: "Tests whether left elements are smaller than the corresponding right ones."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "vec_a"
    description: "Left vector."
  - ctype: "const typename Vec::register_type"
    name: "vec_b"
    description: "Right vector."
returns:
  ctype: "typename Vec::mask_type"
  description: "Vector mask type indicating whether vec_a[*] < vec_b[*]."
testing: #optional
  - requires: ["to_integral", "loadu"]
    includes: ["<cstddef>", "<limits>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count * 2, 0, false};
      bool allOk = true;
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          auto vec1 = &test_helper.data_target()[i];
          auto vec2 = &test_helper.data_target()[element_count + i];
          auto result_mask = less_than<Vec>(loadu<Vec>(vec1), loadu<Vec>(vec2));
          auto result_integral = to_integral<Vec>(result_mask);
          for (size_t i = 0; i < Vec::vector_element_count(); ++i) {
              allOk &= (((result_integral >> i) & 0b1) == (vec1[i] < vec2[i]));
          }
      }
      return allOk;
  - test_name: "equal"
    requires: ["to_integral", "loadu"]
    includes: ["<cstddef>", "<limits>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 0, false};
      bool allOk = true;
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          auto vec1 = loadu<Vec>(&test_helper.data_target()[i]);
          auto result_mask = less_than<Vec>(vec1, vec1);
          auto result_integral = to_integral<Vec>(result_mask);
          for (size_t i = 0; i < Vec::vector_element_count(); ++i) {
              allOk &= (((result_integral >> i) & 0b1) == 0);
          }
      }
      return allOk;
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ['avx512bw']
    implementation: "return _mm512_cmplt_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_cmplt_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_cmplt_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ['avx2']
    implementation: "return _mm256_cmpgt_{{ intrin_tp_full[ctype] }}(vec_b, vec_a);"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ['avx']
    implementation: "return _mm256_cmp_p{{ intrin_tp[ctype][1] }}(vec_a, vec_b, _CMP_LT_OQ);"
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t"]
    lscpu_flags: ['avx2']
    implementation: | 
      return _mm256_andnot_si256(
        _mm256_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b),
        _mm256_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, _mm256_min_{{ intrin_tp_full[ctype] }}(vec_a, vec_b))
      );
    #implementation: "return _mm256_xor_si256(_mm256_set1_epi8(-1), _mm256_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, _mm256_max_{{ intrin_tp_full[ctype] }}(vec_a, vec_b)));"
  - target_extension: "avx2"
    ctype: ["uint64_t"]
    lscpu_flags: ['avx2']
    implementation: | 
      auto const lower_32_bit = _mm256_srli_epi64(_mm256_cmpeq_epi64(_mm256_setzero_si256(), _mm256_setzero_si256()), 32);
      auto const upper_vec_a  = _mm256_srli_epi64(vec_a, 32);
      auto const upper_vec_b  = _mm256_srli_epi64(vec_b, 32);
      auto const lower_vec_a  = _mm256_and_si256(vec_a, lower_32_bit);
      auto const lower_vec_b  = _mm256_and_si256(vec_b, lower_32_bit);

      auto const upper_vec_a_lt_upper_vec_b = _mm256_cmpeq_epi64(upper_vec_a, _mm256_and_si256(lower_32_bit, _mm256_min_epu32(upper_vec_a, upper_vec_b)));
      auto const lower_vec_a_lt_lower_vec_b = _mm256_cmpeq_epi64(lower_vec_a, _mm256_and_si256(lower_32_bit, _mm256_min_epu32(lower_vec_a, lower_vec_b)));
      auto const upper_vec_a_eq_upper_vec_b = _mm256_cmpeq_epi64(upper_vec_a, upper_vec_b);
      auto const lower_vec_a_eq_lower_vec_b = _mm256_cmpeq_epi64(lower_vec_a, lower_vec_b);

      // a < b ?
      /**
       * a_upper <= b_upper | a_upper == b_upper | a_lower <= b_lower | a_upper == b_upper | RESULT
       *         1          |          0         |         *          |         *          |   1
       *         1          |          1         |         1          |         0          |   1
       *         0          |          *         |         *          |         *          |   0
       * -------------------------------------------------------------------------------------------
       * ((a_upper <= b_upper) & (~(a_upper == b_upper))) | ((a_upper <= b_upper) & (a_upper == b_upper) & (a_lower <= b_lower) & ~(a_upper == b_upper))
       * <==>
       * (a_upper <= b_upper) & (~((a_upper == b_upper)&~(a_lower <= b_lower))) & (~((a_upper == b_upper) & (a_upper == b_upper)))
       */
      return 
        _mm256_andnot_si256(
          _mm256_and_si256(upper_vec_a_eq_upper_vec_b, lower_vec_a_eq_lower_vec_b),
          _mm256_andnot_si256(
            _mm256_andnot_si256(lower_vec_a_lt_lower_vec_b, upper_vec_a_eq_upper_vec_b),
            upper_vec_a_lt_upper_vec_b
          )
        );
    # is_native: False
    # implementation: "__m256i sign_bits = _mm256_set1_epi64x(static_cast<int64_t>(1) << 63); return _mm256_cmpgt_epi64(_mm256_xor_si256(vec_b, sign_bits), _mm256_xor_si256(vec_a, sign_bits));"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "int16_t", "int32_t", "float", "double"]
    lscpu_flags: ['sse2']
    implementation: "return _mm_cmplt_{{ intrin_tp_full[ctype] }}(vec_a, vec_b);"
  - target_extension: "sse"
    ctype: ["int64_t"]
    lscpu_flags: ['sse4_2']
    implementation: "return _mm_cmpgt_epi64(vec_b, vec_a);"
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t"]
    lscpu_flags: ['sse2', 'sse4_1']
    implementation: |
      return _mm_andnot_si128(
        _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b),
        _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, _mm_min_{{ intrin_tp_full[ctype] }}(vec_a, vec_b))
      );
    # implementation: "return _mm_xor_si128(_mm_set1_epi8(-1), _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, _mm_max_{{ intrin_tp_full[ctype] }}(vec_a, vec_b)));"
  - target_extension: "sse"
    ctype: ["uint64_t"]
    lscpu_flags: ['sse2', 'sse4_1', 'sse4_2']
    implementation: |
      //vec_a < vec_b === vec_b > vec_a
      auto const lower_32_bit = _mm_srli_epi64(_mm_cmpeq_epi64(_mm_setzero_si128(), _mm_setzero_si128()), 32);
      auto const upper_vec_a  = _mm_srli_epi64(vec_a, 32);
      auto const upper_vec_b  = _mm_srli_epi64(vec_b, 32);
      auto const lower_vec_a  = _mm_and_si128(vec_a, lower_32_bit);
      auto const lower_vec_b  = _mm_and_si128(vec_b, lower_32_bit);

      auto const upper_vec_a_lt_upper_vec_b = _mm_cmpeq_epi64(upper_vec_a, _mm_and_si128(lower_32_bit, _mm_min_epu32(upper_vec_a, upper_vec_b)));
      auto const lower_vec_a_lt_lower_vec_b = _mm_cmpeq_epi64(lower_vec_a, _mm_and_si128(lower_32_bit, _mm_min_epu32(lower_vec_a, lower_vec_b)));
      auto const upper_vec_a_eq_upper_vec_b = _mm_cmpeq_epi64(upper_vec_a, upper_vec_b);
      auto const lower_vec_a_eq_lower_vec_b = _mm_cmpeq_epi64(lower_vec_a, lower_vec_b);

      // a < b ?
      /**
       * a_upper <= b_upper | a_upper == b_upper | a_lower <= b_lower | a_upper == b_upper | RESULT
       *         1          |          0         |         *          |         *          |   1
       *         1          |          1         |         1          |         0          |   1
       *         0          |          *         |         *          |         *          |   0
       * -------------------------------------------------------------------------------------------
       * ((a_upper <= b_upper) & (~(a_upper == b_upper))) | ((a_upper <= b_upper) & (a_upper == b_upper) & (a_lower <= b_lower) & ~(a_upper == b_upper))
       * <==>
       * (a_upper <= b_upper) & (~((a_upper == b_upper)&~(a_lower <= b_lower))) & (~((a_upper == b_upper) & (a_upper == b_upper)))
       */
      return 
        _mm_andnot_si128(
          _mm_and_si128(upper_vec_a_eq_upper_vec_b, lower_vec_a_eq_lower_vec_b),
          _mm_andnot_si128(
            _mm_andnot_si128(lower_vec_a_lt_lower_vec_b, upper_vec_a_eq_upper_vec_b),
            upper_vec_a_lt_upper_vec_b
          )
        );
    # implementation: "__m128i sign_bits = _mm_set1_epi64x(static_cast<int64_t>(1) << 63); return _mm_cmpgt_epi64(_mm_xor_si128(vec_b, sign_bits), _mm_xor_si128(vec_a, sign_bits));"
#ARM - NEON
  - target_extension: "neon"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['neon']
    implementation: "return vcltq_{{ intrin_tp_full[ctype] }}(vec_a, vec_b);"
#SCALAR
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return (vec_a < vec_b);"
#INTEL - FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      using T = typename Vec::register_type;
      T result{};
      // Create a value with all bits set to 1, regardless of underlying type
      {% if ctype in ["float", "double"] %}
      typename Vec::base_type checker;
      memset((void*)&checker, 0xff, sizeof(checker));
      {% else %}
      typename Vec::base_type checker = ~0;
      {% endif %}
      //
      TSL_UNROLL(Vec::vector_element_count())
      for(size_t i = 0; i < Vec::vector_element_count(); ++i) {
        result[i] = (vec_a[i] < vec_b[i]) ? checker : 0;
      }
      return result;
...
---
primitive_name: "greater_than"
brief_description: "Tests whether left elements are larger than or equal to the corresponding right ones."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "vec_a"
    description: "Left vector."
  - ctype: "const typename Vec::register_type"
    name: "vec_b"
    description: "Right vector."
returns:
  ctype: "typename Vec::mask_type"
  description: "Vector mask type indicating whether vec_a[*] > vec_b[*]."
testing: #optional
  - requires: ["to_integral", "loadu"]
    includes: ["<cstddef>", "<limits>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count * 2, 0, false};
      bool allOk = true;
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          auto vec1 = &test_helper.data_target()[i];
          auto vec2 = &test_helper.data_target()[element_count + i];
          auto result_mask = greater_than<Vec>(loadu<Vec>(vec1), loadu<Vec>(vec2));
          auto result_integral = to_integral<Vec>(result_mask);
          for (size_t i = 0; i < Vec::vector_element_count(); ++i) {
              allOk &= (((result_integral >> i) & 0b1) == (vec1[i] > vec2[i]));
          }
      }
      return allOk;
  - test_name: "equal"
    requires: ["to_integral", "loadu"]
    includes: ["<cstddef>", "<limits>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 0, false};
      bool allOk = true;
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          auto vec1 = loadu<Vec>(&test_helper.data_target()[i]);
          auto result_mask = greater_than<Vec>(vec1, vec1);
          auto result_integral = to_integral<Vec>(result_mask);
          for (size_t i = 0; i < Vec::vector_element_count(); ++i) {
              allOk &= (((result_integral >> i) & 0b1) == 0);
          }
      }
      return allOk;
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ['avx512bw']
    implementation: "return _mm512_cmpgt_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_cmpgt_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_cmp_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b, _CMP_GT_OQ);"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ['avx2']
    specialization_comment: "Signed comparison."
    implementation: "return _mm256_cmpgt_{{ intrin_tp_full[ctype] }}(vec_a, vec_b);"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ['avx']
    implementation: "return _mm256_cmp_{{ intrin_tp_full[ctype] }}(vec_a, vec_b, _CMP_GT_OQ);"
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t"]
    lscpu_flags: ['avx2']
    implementation: |
      return _mm256_andnot_si256(
        _mm256_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b),
        _mm256_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, _mm256_max_{{ intrin_tp_full[ctype] }}(vec_a, vec_b))
      );
    # implementation: "return _mm256_xor_si256(_mm256_set1_epi8(-1), _mm256_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_b, _mm256_max_{{ intrin_tp_full[ctype] }}(vec_a, vec_b)));"
  - target_extension: "avx2"
    ctype: ["uint64_t"]
    lscpu_flags: ['avx2']
    # specialization_comment: "Using signed comparison as unsigned by flipping the sign bit."
    implementation: |
      auto const lower_32_bit = _mm256_srli_epi64(_mm256_cmpeq_epi64(_mm256_setzero_si256(), _mm256_setzero_si256()), 32);
      auto const upper_vec_a  = _mm256_srli_epi64(vec_a, 32);
      auto const upper_vec_b  = _mm256_srli_epi64(vec_b, 32);
      auto const lower_vec_a  = _mm256_and_si256(vec_a, lower_32_bit);
      auto const lower_vec_b  = _mm256_and_si256(vec_b, lower_32_bit);

      auto const upper_vec_a_gt_upper_vec_b = _mm256_cmpeq_epi64(upper_vec_a, _mm256_and_si256(lower_32_bit, _mm256_max_epu32(upper_vec_a, upper_vec_b)));
      auto const lower_vec_a_gt_lower_vec_b = _mm256_cmpeq_epi64(lower_vec_a, _mm256_and_si256(lower_32_bit, _mm256_max_epu32(lower_vec_a, lower_vec_b)));
      auto const upper_vec_a_eq_upper_vec_b = _mm256_cmpeq_epi64(upper_vec_a, upper_vec_b);
      auto const lower_vec_a_eq_lower_vec_b = _mm256_cmpeq_epi64(lower_vec_a, lower_vec_b);

      // a > b ?
      /**
       * a_upper >= b_upper | a_upper == b_upper | a_lower >= b_lower | a_upper == b_upper | RESULT
       *         1          |          0         |         *          |         *          |   1
       *         1          |          1         |         1          |         0          |   1
       *         0          |          *         |         *          |         *          |   0
       * -------------------------------------------------------------------------------------------
       * ((a_upper >= b_upper) & (~(a_upper == b_upper))) | ((a_upper >= b_upper) & (a_upper == b_upper) & (a_lower >= b_lower) & ~(a_upper == b_upper))
       * <==>
       * (a_upper >= b_upper) & (~((a_upper == b_upper)&~(a_lower >= b_lower))) & (~((a_upper == b_upper) & (a_upper == b_upper)))
       */
      return 
        _mm256_andnot_si256(
          _mm256_and_si256(upper_vec_a_eq_upper_vec_b, lower_vec_a_eq_lower_vec_b),
          _mm256_andnot_si256(
            _mm256_andnot_si256(lower_vec_a_gt_lower_vec_b, upper_vec_a_eq_upper_vec_b),
            upper_vec_a_gt_upper_vec_b
          )
        );
    # implementation: "__m256i sign_bits = _mm256_set1_epi64x(static_cast<int64_t>(1) << 63); return _mm256_cmpgt_epi64(_mm256_xor_si256(vec_a, sign_bits), _mm256_xor_si256(vec_b, sign_bits));"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "int16_t", "int32_t", "float", "double"]
    lscpu_flags: ['sse2']
    implementation: "return _mm_cmpgt_{{ intrin_tp_full[ctype] }}(vec_a, vec_b);"
  - target_extension: "sse"
    ctype: ["int64_t"]
    lscpu_flags: ['sse4_2']
    implementation: "return _mm_cmpgt_epi64(vec_a, vec_b);"
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t"]
    lscpu_flags: ['sse2', 'sse4_1']
    implementation: |
      return _mm_andnot_si128(
        _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b),
        _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, _mm_max_{{ intrin_tp_full[ctype] }}(vec_a, vec_b))
      );
  - target_extension: "sse"
    ctype: ["uint64_t"]
    lscpu_flags: ['sse2', 'sse4_1', 'sse4_2']
    # specialization_comment: "Using signed comparison as unsigned by flipping the sign bit."
    implementation: |
      auto const lower_32_bit = _mm_srli_epi64(_mm_cmpeq_epi64(_mm_setzero_si128(), _mm_setzero_si128()), 32);
      auto const upper_vec_a  = _mm_srli_epi64(vec_a, 32);
      auto const upper_vec_b  = _mm_srli_epi64(vec_b, 32);
      auto const lower_vec_a  = _mm_and_si128(vec_a, lower_32_bit);
      auto const lower_vec_b  = _mm_and_si128(vec_b, lower_32_bit);

      auto const upper_vec_a_gt_upper_vec_b = _mm_cmpeq_epi64(upper_vec_a, _mm_and_si128(lower_32_bit, _mm_max_epu32(upper_vec_a, upper_vec_b)));
      auto const lower_vec_a_gt_lower_vec_b = _mm_cmpeq_epi64(lower_vec_a, _mm_and_si128(lower_32_bit, _mm_max_epu32(lower_vec_a, lower_vec_b)));
      auto const upper_vec_a_eq_upper_vec_b = _mm_cmpeq_epi64(upper_vec_a, upper_vec_b);
      auto const lower_vec_a_eq_lower_vec_b = _mm_cmpeq_epi64(lower_vec_a, lower_vec_b);

      // a > b ?
      /**
       * a_upper >= b_upper | a_upper == b_upper | a_lower >= b_lower | a_upper == b_upper | RESULT
       *         1          |          0         |         *          |         *          |   1
       *         1          |          1         |         1          |         0          |   1
       *         0          |          *         |         *          |         *          |   0
       * -------------------------------------------------------------------------------------------
       * ((a_upper <= b_upper) & (~(a_upper == b_upper))) | ((a_upper >= b_upper) & (a_upper == b_upper) & (a_lower <= b_lower) & ~(a_upper == b_upper))
       * <==>
       * (a_upper >= b_upper) & (~((a_upper == b_upper)&~(a_lower >= b_lower))) & (~((a_upper == b_upper) & (a_upper == b_upper)))
       */
      return
        _mm_andnot_si128(
          _mm_and_si128(upper_vec_a_eq_upper_vec_b, lower_vec_a_eq_lower_vec_b),
          _mm_andnot_si128(
            _mm_andnot_si128(lower_vec_a_gt_lower_vec_b, upper_vec_a_eq_upper_vec_b),
            upper_vec_a_gt_upper_vec_b
          )
        );
    #implementation: "__m128i sign_bits = _mm_set1_epi64x(static_cast<int64_t>(1) << 63); return _mm_cmpgt_epi64(_mm_xor_si128(vec_a, sign_bits), _mm_xor_si128(vec_b, sign_bits));"
#ARM - NEON
  - target_extension: "neon"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['neon']
    implementation: "return vcgtq_{{ intrin_tp_full[ctype] }}(vec_a, vec_b);"
#SCALAR
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return (vec_a > vec_b);"
#INTEL - FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      using T = typename Vec::register_type;
      T result{};
      // Create a value with all bits set to 1, regardless of underlying type
      {% if ctype in ["float", "double"] %}
      typename Vec::base_type checker;
      memset((void*)&checker, 0xff, sizeof(checker));
      {% else %}
      typename Vec::base_type checker = ~0;
      {% endif %}
      //
      TSL_UNROLL(Vec::vector_element_count())
      for(size_t i = 0; i < Vec::vector_element_count(); ++i) {
        result[i] = (vec_a[i] > vec_b[i]) ? checker : 0;
      }
      return result;
...
---
primitive_name: "less_than_or_equal"
brief_description: "Tests whether left elements are smaller than or equal to the corresponding right ones."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "vec_a"
    description: "Left vector."
  - ctype: "const typename Vec::register_type"
    name: "vec_b"
    description: "Right vector."
returns:
  ctype: "typename Vec::mask_type"
  description: "Vector mask type indicating whether vec_a[*] <= vec_b[*]."
testing: #optional
  - requires: ["to_integral", "loadu"]
    includes: ["<cstddef>", "<limits>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count * 2, 0, false};
      bool allOk = true;
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          auto vec1 = &test_helper.data_target()[i];
          auto vec2 = &test_helper.data_target()[element_count + i];
          auto result_mask = less_than_or_equal<Vec>(loadu<Vec>(vec1), loadu<Vec>(vec2));
          auto result_integral = to_integral<Vec>(result_mask);
          for (size_t i = 0; i < Vec::vector_element_count(); ++i) {
              allOk &= (((result_integral >> i) & 0b1) == (vec1[i] <= vec2[i]));
          }
      }
      return allOk;
  - test_name: "equal"
    requires: ["to_integral", "loadu"]
    includes: ["<cstddef>", "<limits>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 0, false};
      bool allOk = true;
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          auto vec1 = loadu<Vec>(&test_helper.data_target()[i]);
          auto result_mask = less_than_or_equal<Vec>(vec1, vec1);
          auto result_integral = to_integral<Vec>(result_mask);
          for (size_t i = 0; i < Vec::vector_element_count(); ++i) {
              allOk &= (((result_integral >> i) & 0b1) == 1);
          }
      }
      return allOk;
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ['avx512bw']
    implementation: "return _mm512_cmple_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_cmple_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_cmple_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ['avx2']
    implementation: |
      return
        _mm256_andnot_si256(
          _mm256_cmpgt_{{ intrin_tp_full[ctype] }}(vec_a, vec_b),
          _mm256_cmpeq_{{ intrin_tp_full[ctype] }}(_mm256_setzero_si256(), _mm256_setzero_si256())
        );
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ['avx']
    implementation: "return _mm256_cmp_p{{ intrin_tp[ctype][1] }}(vec_a, vec_b, _CMP_LE_OQ);"
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t"]
    lscpu_flags: ['avx2']
    implementation: |
      return _mm256_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, _mm256_min_{{ intrin_tp_full[ctype] }}(vec_a, vec_b));
  - target_extension: "avx2"
    ctype: ["uint64_t"]
    lscpu_flags: ['avx2']
    implementation: |
      auto const lower_32_bit = _mm256_srli_epi64(_mm256_cmpeq_epi64(_mm256_setzero_si256(), _mm256_setzero_si256()), 32);
      auto const upper_vec_a  = _mm256_srli_epi64(vec_a, 32);
      auto const upper_vec_b  = _mm256_srli_epi64(vec_b, 32);
      auto const lower_vec_a  = _mm256_and_si256(vec_a, lower_32_bit);
      auto const lower_vec_b  = _mm256_and_si256(vec_b, lower_32_bit);

      auto const upper_vec_a_le_upper_vec_b = _mm256_cmpeq_epi64(upper_vec_a, _mm256_and_si256(lower_32_bit, _mm256_min_epu32(upper_vec_a, upper_vec_b)));
      auto const lower_vec_a_le_lower_vec_b = _mm256_cmpeq_epi64(lower_vec_a, _mm256_and_si256(lower_32_bit, _mm256_min_epu32(lower_vec_a, lower_vec_b)));
      auto const upper_vec_a_eq_upper_vec_b = _mm256_cmpeq_epi64(upper_vec_a, upper_vec_b);

      // a <= b ?
      /**
       * a_upper <= b_upper | a_upper == b_upper | a_lower <= b_lower | a_upper == b_upper | RESULT
       *         1          |          0         |         *          |         *          |   1
       *         1          |          1         |         1          |         *          |   1
       *         0          |          *         |         *          |         *          |   0
       * -------------------------------------------------------------------------------------------
       * ((a_upper <= b_upper) & (~(a_upper == b_upper)))| ((a_upper <= b_upper) & (a_upper == b_upper) & (a_lower <= b_lower))
       * <==>
       * (a_upper <= b_upper) & (~((a_upper == b_upper) & ~(a_lower <= b_lower)))
       */
      return _mm256_andnot_si256(
        _mm256_andnot_si256(lower_vec_a_le_lower_vec_b, upper_vec_a_eq_upper_vec_b),
        upper_vec_a_le_upper_vec_b
      );
    # implementation: |
    # __m256i sign_bits = _mm256_set1_epi64x(static_cast<int64_t>(1) << 63);
    # return _mm256_xor_si256(_mm256_set1_epi8(-1), _mm256_cmpgt_epi64(_mm256_xor_si256(vec_a, sign_bits), _mm256_xor_si256(vec_b, sign_bits)));
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "int16_t", "int32_t"]
    lscpu_flags: ['sse2']
    implementation: |
      return _mm_or_si128(_mm_cmpeq_{{ intrin_tp_full[ctype] }}(vec_a, vec_b), _mm_cmpgt_{{ intrin_tp_full[ctype] }}(vec_b, vec_a));
    # implementation: "return  _mm_xor_si128(_mm_set1_epi8(-1), _mm_cmpgt_{{ intrin_tp_full[ctype] }}(vec_a, vec_b));"
  - target_extension: "sse"
    ctype: ["float", "double"]
    lscpu_flags: ['sse2']
    implementation: "return _mm_cmple_{{ intrin_tp_full[ctype] }}(vec_a, vec_b);"
  - target_extension: "sse"
    ctype: ["int64_t"]
    lscpu_flags: ['sse4_2']
    implementation: "return _mm_or_si128(_mm_cmpeq_epi64(vec_a, vec_b), _mm_cmpgt_epi64(vec_b, vec_a));"
    # implementation: "return _mm_xor_si128(_mm_set1_epi8(-1), _mm_cmpgt_epi64(vec_a, vec_b));"
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t"]
    lscpu_flags: ['sse2', 'sse4_1']
    implementation: |
      return _mm_or_si128(
        _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b),
        _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, _mm_min_{{ intrin_tp_full[ctype] }}(vec_a, vec_b))
      );
    # {% if ctype == "uint16_t" %}
    # __m128i sign_bits = _mm_set1_epi16(0x8000);
    # {% endif %}
    # {% if ctype == "uint32_t" %}
    # __m128i sign_bits = _mm_set1_epi32(0x80000000);
    # {% endif %}
    # {% if ctype == "uint64_t" %}
    # __m128i sign_bits = _mm_set1_epi64x(static_cast<int64_t>(0x8000000000000000));
    # {% endif %}
    # return _mm_xor_si128(_mm_set1_epi8(-1), _mm_cmpgt_epi{{ intrin_tp[ctype][1] }}(_mm_xor_si128(vec_a, sign_bits), _mm_xor_si128(vec_b, sign_bits)));
  - target_extension: "sse"
    ctype: ["uint64_t"]
    lscpu_flags: ['sse2', 'sse4_1', 'sse4_2']
    implementation: |
      auto const lower_32_bit = _mm_srli_epi64(_mm_cmpeq_epi64(_mm_setzero_si128(), _mm_setzero_si128()), 32);
      auto const upper_vec_a  = _mm_srli_epi64(vec_a, 32);
      auto const upper_vec_b  = _mm_srli_epi64(vec_b, 32);
      auto const lower_vec_a  = _mm_and_si128(vec_a, lower_32_bit);
      auto const lower_vec_b  = _mm_and_si128(vec_b, lower_32_bit);

      auto const upper_vec_a_le_upper_vec_b = _mm_cmpeq_epi64(upper_vec_a, _mm_and_si128(lower_32_bit, _mm_min_epu32(upper_vec_a, upper_vec_b))); 
      auto const lower_vec_a_le_lower_vec_b = _mm_cmpeq_epi64(lower_vec_a, _mm_and_si128(lower_32_bit, _mm_min_epu32(lower_vec_a, lower_vec_b)));
      auto const upper_vec_a_eq_upper_vec_b = _mm_cmpeq_epi64(upper_vec_a, upper_vec_b);

      // a <= b ?
      /**
       * a_upper <= b_upper | a_upper == b_upper | a_lower <= b_lower | a_upper == b_upper | RESULT
       *         1          |          0         |         *          |         *          |   1
       *         1          |          1         |         1          |         *          |   1
       *         1          |          1         |         0          |         0          |   0
       *         0          |          *         |         *          |         *          |   0
       * -------------------------------------------------------------------------------------------
       * (A & ~B) | (A & B & C) <==> A & ~(B & ~C) <==> ~(~c & B) & A
       * ((a_upper <= b_upper) & (~(a_upper == b_upper)))| ((a_upper == b_upper) & (a_lower <= b_lower) & (a_lower <= b_lower))
       * <==>
       * (a_upper <= b_upper) & (~((a_upper == b_upper) & ~(a_lower <= b_lower)))
       */
      return _mm_andnot_si128(
        _mm_andnot_si128(lower_vec_a_le_lower_vec_b, upper_vec_a_eq_upper_vec_b),
        upper_vec_a_le_upper_vec_b
      );
#ARM - NEON
  - target_extension: "neon"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['neon']
    implementation: "return vcleq_{{ intrin_tp_full[ctype] }}(vec_a, vec_b);"
#SCALAR
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return (vec_a <= vec_b);"
#INTEL - FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      using T = typename Vec::register_type;
      T result{};
      // Create a value with all bits set to 1, regardless of underlying type
      {% if ctype in ["float", "double"] %}
      typename Vec::base_type checker;
      memset((void*)&checker, 0xff, sizeof(checker));
      {% else %}
      typename Vec::base_type checker = ~0;
      {% endif %}
      //
      TSL_UNROLL(Vec::vector_element_count())
      for(size_t i = 0; i < Vec::vector_element_count(); ++i) {
        result[i] = (vec_a[i] <= vec_b[i]) ? checker : 0;
      }
      return result;
...
---
primitive_name: "greater_than_or_equal"
brief_description: "Tests whether left elements are larger than the corresponding right ones."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "vec_a"
    description: "Left vector."
  - ctype: "const typename Vec::register_type"
    name: "vec_b"
    description: "Right vector."
returns:
  ctype: "typename Vec::mask_type"
  description: "Vector mask type indicating whether vec_a[*] >= vec_b[*]."
testing: #optional
  - requires: ["to_integral", "loadu"]
    includes: ["<cstddef>", "<limits>", "<iostream>", "<bitset>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count * 2, 0, false};
      bool allOk = true;
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          auto vec1 = &test_helper.data_target()[i];
          auto vec2 = &test_helper.data_target()[element_count + i];
          auto result_mask = greater_than_or_equal<Vec>(loadu<Vec>(vec1), loadu<Vec>(vec2));
          auto result_integral = to_integral<Vec>(result_mask);
          for (size_t j = 0; j < Vec::vector_element_count(); ++j) {
              auto tmp_ok = (((result_integral >> j) & 0b1) == (vec1[j] >= vec2[j]));
              allOk &= tmp_ok;
              if (!tmp_ok) {
                std::cout << "Wrong result in greater_than_or_equal default for " << tsl::type_name<Vec>() << " (size of T: " << sizeof(typename Vec::base_type) << ")" << " at index " << i << std::endl;
                auto bm = std::bitset<Vec::vector_element_count()>((unsigned long long)result_integral);
                std::cout << "[" << i+j << "]: ";
                std::cout << vec1[j] << " >= " << vec2[j] << " ? " << bm[j] << std::endl;
              }
          }
      }
      return allOk;
  - test_name: "equal"
    requires: ["to_integral", "loadu"]
    includes: ["<cstddef>", "<limits>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 0, false};
      bool allOk = true;
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          auto vec1 = loadu<Vec>(&test_helper.data_target()[i]);
          auto result_mask = greater_than_or_equal<Vec>(vec1, vec1);
          auto result_integral = to_integral<Vec>(result_mask);
          for (size_t i = 0; i < Vec::vector_element_count(); ++i) {
              allOk &= (((result_integral >> i) & 0b1) == 1);
          }
      }
      return allOk;
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ['avx512bw']
    implementation: "return _mm512_cmpge_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_cmpge_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_cmp_{{ intrin_tp_full[ctype] }}_mask(vec_a, vec_b, _CMP_GE_OQ);"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ['avx2']
    implementation: |
      return
        _mm256_or_si256(
          _mm256_cmpgt_{{ intrin_tp_full[ctype] }}(vec_a, vec_b),
          _mm256_cmpeq_{{ intrin_tp_full[ctype] }}(vec_a, vec_b)
        );
    #implementation:  "return _mm256_xor_si256(_mm256_set1_epi8(-1), _mm256_cmpgt_{{ intrin_tp_full[ctype] }}(vec_b, vec_a));"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ['avx']
    implementation: "return _mm256_cmp_{{ intrin_tp_full[ctype] }}(vec_a, vec_b, _CMP_GE_OQ);"
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t"]
    lscpu_flags: ['avx2']
    is_native: False
    implementation: "return _mm256_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, _mm256_max_{{ intrin_tp_full[ctype] }}(vec_a, vec_b));"
  - target_extension: "avx2"
    ctype: ["uint64_t"]
    lscpu_flags: ['avx2']
    implementation: |
      auto const lower_32_bit = _mm256_srli_epi64(_mm256_cmpeq_epi64(_mm256_setzero_si256(), _mm256_setzero_si256()), 32);
      auto const upper_vec_a  = _mm256_srli_epi64(vec_a, 32);
      auto const upper_vec_b  = _mm256_srli_epi64(vec_b, 32);
      auto const lower_vec_a  = _mm256_and_si256(vec_a, lower_32_bit);
      auto const lower_vec_b  = _mm256_and_si256(vec_b, lower_32_bit);

      auto const upper_vec_a_ge_upper_vec_b = _mm256_cmpeq_epi64(upper_vec_a, _mm256_and_si256(lower_32_bit, _mm256_max_epu32(upper_vec_a, upper_vec_b)));
      auto const lower_vec_a_ge_lower_vec_b = _mm256_cmpeq_epi64(lower_vec_a, _mm256_and_si256(lower_32_bit, _mm256_max_epu32(lower_vec_a, lower_vec_b)));
      auto const upper_vec_a_eq_upper_vec_b = _mm256_cmpeq_epi64(upper_vec_a, upper_vec_b);

      // a >= b ?
      /**
       * a_upper >= b_upper | a_upper == b_upper | a_lower >= b_lower | a_upper == b_upper | RESULT
       *         1          |          0         |         *          |         *          |   1
       *         1          |          1         |         1          |         *          |   1
       *         0          |          *         |         *          |         *          |   0
       * -------------------------------------------------------------------------------------------
       * ((a_upper >= b_upper) & (~(a_upper == b_upper)))| ((a_upper == b_upper) & (a_lower >= b_lower))
       * <==>
       * (a_upper >= b_upper) & (~((a_upper == b_upper) & ~(a_lower >= b_lower)))
       */
      return _mm256_andnot_si256(
        _mm256_andnot_si256(
          lower_vec_a_ge_lower_vec_b, 
          upper_vec_a_eq_upper_vec_b
        ),
        upper_vec_a_ge_upper_vec_b
      );
    #specialization_comment: "Using signed comparison as unsigned by flipping the sign bit."
    #is_native: False
    #implementation: |
    #  __m256i sign_bits = _mm256_set1_epi64x(static_cast<int64_t>(1) << 63);
    #  __m256i less_than = _mm256_cmpgt_epi64(_mm256_xor_si256(vec_b, sign_bits), _mm256_xor_si256(vec_a, sign_bits));
    #  return _mm256_xor_si256(_mm256_set1_epi8(-1), less_than);
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "int16_t", "int32_t"]
    lscpu_flags: ['sse2']
    implementation: |
      return _mm_or_si128(_mm_cmpeq_{{ intrin_tp_full[ctype] }}(vec_a, vec_b), _mm_cmpgt_{{ intrin_tp_full[ctype] }}(vec_a, vec_b));
    #specialization_comment: "Signed comparison."
    #implementation: "return _mm_xor_si128(_mm_set1_epi8(-1), _mm_cmpgt_{{ intrin_tp_full[ctype] }}(vec_b, vec_a));"
  - target_extension: "sse"
    ctype: ["int64_t"]
    lscpu_flags: ['sse4_2']
    implementation: "return _mm_or_si128(_mm_cmpeq_epi64(vec_a, vec_b), _mm_cmpgt_epi64(vec_a, vec_b));"
    #implementation: "return _mm_xor_si128(_mm_set1_epi8(-1), _mm_cmpgt_{{ intrin_tp_full[ctype] }}(vec_b, vec_a));"
  - target_extension: "sse"
    ctype: [ "float", "double"]
    lscpu_flags: ['sse2']
    implementation: "return _mm_cmpge_{{ intrin_tp_full[ctype] }}(vec_a, vec_b);"
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t"]
    lscpu_flags: ['sse2', 'sse4_1']
    implementation: |
      return _mm_or_si128(
        _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, vec_b),
        _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, _mm_max_{{ intrin_tp_full[ctype] }}(vec_a, vec_b))
      );
    #implementation: "return _mm_cmpeq_epi{{ intrin_tp[ctype][1] }}(vec_a, _mm_max_{{ intrin_tp_full[ctype] }}(vec_a, vec_b));"
  - target_extension: "sse"
    ctype: ["uint64_t"]
    lscpu_flags: ['sse2', 'sse4_1', 'sse4_2']
    implementation: |
      auto const lower_32_bit = _mm_srli_epi64(_mm_cmpeq_epi64(_mm_setzero_si128(), _mm_setzero_si128()), 32);
      auto const upper_vec_a  = _mm_srli_epi64(vec_a, 32);
      auto const upper_vec_b  = _mm_srli_epi64(vec_b, 32);
      auto const lower_vec_a  = _mm_and_si128(vec_a, lower_32_bit);
      auto const lower_vec_b  = _mm_and_si128(vec_b, lower_32_bit);

      auto const upper_vec_a_ge_upper_vec_b = _mm_cmpeq_epi64(upper_vec_a, _mm_and_si128(lower_32_bit, _mm_max_epu32(upper_vec_a, upper_vec_b)));
      auto const lower_vec_a_ge_lower_vec_b = _mm_cmpeq_epi64(lower_vec_a, _mm_and_si128(lower_32_bit, _mm_max_epu32(lower_vec_a, lower_vec_b)));
      auto const upper_vec_a_eq_upper_vec_b = _mm_cmpeq_epi64(upper_vec_a, upper_vec_b);

      // a >= b ?
      /**
       * a_upper >= b_upper | a_upper == b_upper | a_lower >= b_lower | a_upper == b_upper | RESULT
       *         1          |          0         |         *          |         *          |   1
       *         1          |          1         |         1          |         *          |   1
       *         0          |          *         |         *          |         *          |   0
       * -------------------------------------------------------------------------------------------
       * ((a_upper >= b_upper) & (~(a_upper == b_upper)))| ((a_upper == b_upper) & (a_lower >= b_lower))
       * <==>
       * (a_upper >= b_upper) & (~((a_upper == b_upper) & ~(a_lower >= b_lower)))
       */
      return _mm_andnot_si128(
        _mm_andnot_si128(
          lower_vec_a_ge_lower_vec_b, 
          upper_vec_a_eq_upper_vec_b
        ),
        upper_vec_a_ge_upper_vec_b
      );
    #specialization_comment: "Using signed comparison as unsigned by flipping the sign bit."
    #is_native: False
    #implementation: |
    #  __m128i sign_bits = _mm_set1_epi64x(static_cast<int64_t>(1) << 63);
    #  __m128i less_than = _mm_cmpgt_epi64(_mm_xor_si128(vec_b, sign_bits), _mm_xor_si128(vec_a, sign_bits));
    #  return _mm_xor_si128(_mm_set1_epi8(-1), less_than);
#ARM - NEON
  - target_extension: "neon"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['neon']
    implementation: "return vcgeq_{{ intrin_tp_full[ctype] }}(vec_a, vec_b);"
#SCALAR
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return (vec_a >= vec_b);"
#INTEL - FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      using T = typename Vec::register_type;
      T result{};
      // Create a value with all bits set to 1, regardless of underlying type
      {% if ctype in ["float", "double"] %}
      typename Vec::base_type checker;
      memset((void*)&checker, 0xff, sizeof(checker));
      {% else %}
      typename Vec::base_type checker = ~0;
      {% endif %}
      //
      TSL_UNROLL(Vec::vector_element_count())
      for(size_t i = 0; i < Vec::vector_element_count(); ++i) {
        result[i] = (vec_a[i] >= vec_b[i]) ? checker : 0;
      }
      return result;
...
---
primitive_name: "between_inclusive"
brief_description: "Checks if the values of a vector are in a specific range (min[*] <= d[*] <= max[*])."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "vec_data"
    description: "Data vector."
  - ctype: "const typename Vec::register_type"
    name: "vec_min"
    description: "Minimum vector."
  - ctype: "typename Vec::register_type"
    attributes: "const"
    name: "vec_max"
    description: "Maximum vector."
returns:
  ctype: "typename Vec::mask_type"
  description: "Vector mask type indicating whether the data is in the given range."
testing:
  - test_name: "complete_range"
    requires: ["to_integral", "loadu", "set1"]
    includes: ["<cstddef>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 1, false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();

      auto vec_min = set1<Vec>(0);
      auto vec_max = set1<Vec>(std::numeric_limits<T>::max());

      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
        *reference_result_ptr = Vec::vector_element_count();
        auto vec = loadu<Vec>(&test_data_ptr[i]);
        auto result_mask = between_inclusive<Vec>( vec, vec_min, vec_max );
        auto result_integral = to_integral<Vec>( result_mask );
        size_t matches = 0;
        for ( size_t i = 0; i < Vec::vector_element_count(); ++i ) {
          if(((result_integral >> i) & 0b1) == 1) {
            matches += 1;
          }
        }
        *test_result_ptr = matches;
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
  - test_name: "not_in_range"
    requires: ["to_integral", "loadu", "set1"]
    includes: ["<cstddef>", "<bitset>", "<iostream>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 1, false, testing::alternate_init_no_zero<T>};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      auto vec_min = set1<Vec>(0);
      auto vec_max = set1<Vec>(0);
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
        *reference_result_ptr = 0;
        auto vec = loadu<Vec>(&test_data_ptr[i]);
        auto result_mask = between_inclusive<Vec>( vec, vec_min, vec_max );
        auto result_integral = to_integral<Vec>( result_mask );
        if (result_integral != 0) {
          auto ltmin = std::bitset<Vec::vector_element_count()>{(unsigned long long)to_integral<Vec>(less_than_or_equal<Vec>(vec_min, vec))};
          auto gtmax = std::bitset<Vec::vector_element_count()>{(unsigned long long)to_integral<Vec>(less_than_or_equal<Vec>(vec, vec_max))};
          auto r     = std::bitset<Vec::vector_element_count()>{(unsigned long long)result_integral};
          std::cout << "Wrong result for " << tsl::type_name<Vec>() << " (size of T: " << sizeof(typename Vec::base_type) << ")" << " at index " << i << std::endl;
          for ( size_t i = 0; i < Vec::vector_element_count(); ++i ) {
            std::cout <<"[" << i << "]: " << "0 < " << (int)test_data_ptr[i] << " ? => " << ltmin[i] << " & " << (int)test_data_ptr[i] << " < 0 ? => " << gtmax[i] << " ==> " << r[i] << "\n";
          }
        }
        size_t matches = 0;
        for ( size_t i = 0; i < Vec::vector_element_count(); ++i ) {
          if(((result_integral >> i) & 0b1) == 1) {
            matches += 1;
          }
        }
        *test_result_ptr = matches;
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
  - test_name: "check_boundaries"
    requires: ["to_integral", "loadu", "set1"]
    includes: ["<cstddef>"]
    implementation: |
      using T = typename Vec::base_type;
      testing::test_memory_helper_t<Vec> test_helper{ 1, false };
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();
      auto vec = set1<Vec>(0);
      auto result_mask = between_inclusive<Vec>(vec, vec, vec);
      auto result_imask = to_integral<Vec>(result_mask);
      size_t matches = 0;
      for ( size_t i = 0; i < Vec::vector_element_count(); ++i ) {
        if(((result_imask >> i) & 0b1) == 1) {
          matches += 1;
        }
      }
      *test_result_ptr = matches;
      *reference_result_ptr = Vec::vector_element_count();
      test_helper.synchronize();
      return test_helper.validate();
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ['avx512f', 'avx512bw']
    implementation: |
      return functors::less_than_or_equal<Vec, Idof>::apply(vec_min, vec_data) & functors::less_than_or_equal<Vec, Idof>::apply(vec_data, vec_max);
  - target_extension: "avx512"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ['avx512f']
    implementation: |
      return functors::less_than_or_equal<Vec, Idof>::apply(vec_min, vec_data) & functors::less_than_or_equal<Vec, Idof>::apply(vec_data, vec_max);
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: [ 'avx2' ]
    implementation: |
      return _mm256_and_si256(functors::less_than_or_equal<Vec, Idof>::apply(vec_min, vec_data), functors::less_than_or_equal<Vec, Idof>::apply(vec_data, vec_max));
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ['avx']
    implementation: |
      return _mm256_and_{{ intrin_tp_full[ctype] }}(functors::less_than_or_equal<Vec, Idof>::apply(vec_min, vec_data), functors::less_than_or_equal<Vec, Idof>::apply(vec_data, vec_max));
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ['sse2', 'sse4_1', 'sse4_2']
    implementation: |
      return _mm_and_si128(functors::less_than_or_equal<Vec, Idof>::apply(vec_min, vec_data), functors::less_than_or_equal<Vec, Idof>::apply(vec_data, vec_max));
#  - target_extension: "sse"
#    ctype: "uint64_t"
#    lscpu_flags: ['sse2']
#    is_native: False
#    specialization_comment: "@todo: This is a very bad implementation. It should be replaced by a better one."
#    implementation: |
#      typedef std::array<uint64_t, 2> arr_t __attribute__((aligned(16)));
#      arr_t data, min, max, result;
#      _mm_store_si128(reinterpret_cast<__m128i*>(data.data()), vec_data);
#      _mm_store_si128(reinterpret_cast<__m128i*>(min.data()), vec_min);
#      _mm_store_si128(reinterpret_cast<__m128i*>(max.data()), vec_max);
#      result[0] = (data[0] >= min[0]) && (data[0] <= max[0]) ? 0 : 1;
#      result[1] = (data[1] >= min[1]) && (data[1] <= max[1]) ? 0 : 1;
#      return _mm_cmpeq_epi64(
#        _mm_load_si128(reinterpret_cast<__m128i*>(result.data())),
#        _mm_setzero_si128()
#      );
  - target_extension: "sse"
    ctype: ["float", "double"]
    lscpu_flags: ['sse2']
    implementation: |
      return _mm_and_{{ intrin_tp_full[ctype] }}(functors::less_than_or_equal<Vec, Idof>::apply(vec_min, vec_data), functors::less_than_or_equal<Vec, Idof>::apply(vec_data, vec_max));
#ARM - NEON
  - target_extension: "neon"
    ctype: "int64_t"
    lscpu_flags: [ 'neon' ]
    implementation: "return vandq_u64( vcgeq_s64( vec_data, vec_min ), vcleq_s64( vec_data, vec_max ) );"
#INTEL - FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      using T = typename Vec::register_type;
      T result{};
      // Create a value with all bits set to 1, regardless of underlying type
      {% if ctype in ["float", "double"] %}
      typename Vec::base_type checker;
      memset((void*)&checker, 0xff, sizeof(checker));
      {% else %}
      typename Vec::base_type checker = ~0;
      {% endif %}
      //
      TSL_UNROLL(Vec::vector_element_count())
      for(size_t i = 0; i < Vec::vector_element_count(); ++i) {
        result[i] = ((vec_data[i] >= vec_min[i]) && (vec_data[i] <= vec_max[i])) ? checker : 0;
      }
      return result;
#SCALAR
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return (vec_data >= vec_min && vec_data <= vec_max);"
...
---
primitive_name: "unequal_zero"
brief_description: "Checks if the vector register contains at least one value unequal zero."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "vec"
    description: "Operating Vector"
returns:
  ctype: "bool"
  description: "Result indicating if the vector register contains at least one value unequal to zero."
testing:
  - test_name: "with_only_zero"
    requires: ["set_zero"]
    includes: ["<cstddef>"]
    implementation: |
      using T = typename Vec::base_type;
      testing::test_memory_helper_t<Vec> test_helper{1, false};
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();
      *reference_result_ptr = 0;
      *test_result_ptr = unequal_zero<Vec>(set_zero<Vec>());
      test_helper.synchronize();
      return test_helper.validate();
  - test_name: "with_only_one"
    requires: ["set1"]
    includes: ["<cstddef>"]
    implementation: |
      using T = typename Vec::base_type;
      testing::test_memory_helper_t<Vec> test_helper{1, false};
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();
      auto vec = set1<Vec>(1);
      *reference_result_ptr = 1;
      *test_result_ptr = unequal_zero<Vec>(vec);
      test_helper.synchronize();
      return test_helper.validate();
  - test_name: "with_sequence"
    requires: ["sequence"]
    includes: ["<cstddef>"]
    implementation: |
      using T = typename Vec::base_type;
      testing::test_memory_helper_t<Vec> test_helper{1, false};
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();
      auto vec = sequence<Vec>();
      *reference_result_ptr = (bool) (Vec::vector_element_count() - 1);
      *test_result_ptr = unequal_zero<Vec>(vec);
      test_helper.synchronize();
      return test_helper.validate();
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t"]
    lscpu_flags: ['avx512f', 'avx512bw']
    implementation: return (_mm512_cmpneq_{{intrin_tp_full[ctype]}}_mask(vec, _mm512_setzero_si512()));
  - target_extension: "avx512"
    ctype: ["int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx512f']
    implementation: return (_mm512_cmpneq_{{intrin_tp_full[ctype]}}_mask(vec, _mm512_setzero_si512()));
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ['avx512f', 'avx512bw']
    implementation: return (_mm512_cmp_{{intrin_tp_full[ctype]}}_mask(vec, _mm512_setzero_{{intrin_tp_full[ctype]}}(), _CMP_NEQ_OQ) != 0);
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx2']
    implementation: return (_mm256_testz_si256(vec,vec) == 0);
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ['avx2']
    implementation: return (_mm256_movemask_{{intrin_tp_full[ctype]}}(_mm256_cmp_{{intrin_tp_full[ctype]}}(vec, _mm256_setzero_{{intrin_tp_full[ctype]}}(), _CMP_NEQ_UQ)) != 0);
#INTEL - SSE
  - target_extension: "sse"
    ctype: [ "float", "double" ]
    lscpu_flags: [ 'sse2' ]
    implementation: return (_mm_movemask_{{intrin_tp_full[ctype]}}(_mm_cmpneq_{{intrin_tp_full[ctype]}}(vec, _mm_setzero_{{intrin_tp_full[ctype]}}())) != 0);
  - target_extension: "sse"
    ctype: ["uint16_t", "int16_t", "uint32_t", "int32_t", "uint8_t", "int8_t", "uint64_t", "int64_t"]
    lscpu_flags: ['sse4_1']
    implementation: return (_mm_testz_si128(vec, vec) == 0);
#SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
    lscpu_flags: [ ]
    implementation: "return static_cast<bool>(vec);"
#ARM - NEON
#INTEL - FPGA
...
---
primitive_name: "count_matches"
brief_description: "Counts number of matches of a chosen value within a vector register."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "vec"
    description: "Operating Vector"
  - ctype: "const typename Vec::base_type"
    name: "val"
    description: "Compared value"
returns:
  ctype: "typename Vec::base_type"
  description: "Result of the count"
testing:
  - test_name: "with_only_zero_searching_zero"
    requires: ["set1"]
    includes: [ ]
    implementation: |
      using T = typename Vec::base_type;
      testing::test_memory_helper_t<Vec> test_helper{1, false};
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();
      auto vec = set1<Vec>(0);
      auto val = 0;
      *reference_result_ptr = Vec::vector_element_count();
      *test_result_ptr = count_matches<Vec>(vec, val);
      test_helper.synchronize();
      return test_helper.validate();
  - test_name: "with_only_zero_searching_one"
    requires: ["set1"]
    includes: [ ]
    implementation: |
      using T = typename Vec::base_type;
      testing::test_memory_helper_t<Vec> test_helper{1, false};
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();
      auto vec = set1<Vec>(0);
      auto val = 1;
      *reference_result_ptr = 0;
      *test_result_ptr = count_matches<Vec>(vec, val);
      test_helper.synchronize();
      return test_helper.validate();
  - test_name: "with_one_match"
    requires: ["loadu", "set1"]
    includes: [ ]
    implementation: |
      using T = typename Vec::base_type;
      testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), 1, false, testing::seq_init<T>, 1};
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      auto vec = loadu<Vec>(test_data_ptr);
      auto val = Vec::vector_element_count();
      *reference_result_ptr = 1;
      *test_result_ptr = count_matches<Vec>(vec, val);
      test_helper.synchronize();
      return test_helper.validate();
definitions:
# INTEL - AVX512
  - target_extension: 'avx512'
    ctype: [ 'uint8_t', 'int8_t']
    lscpu_flags: [ 'avx512f', 'avx512bw' ]
    implementation: |
      Vec::base_type result = 0;
      __m512i target_value = _mm512_set1_epi8(val);
      __mmask64 cmp_result = _mm512_cmpeq_epi8_mask(vec, target_value);
      uint64_t mask_bits = static_cast<uint64_t>(cmp_result);
      while (mask_bits != 0) {
        result += mask_bits & 1;
        mask_bits >>= 1;
      }
      return result;
  - target_extension: 'avx512'
    ctype: [ 'uint16_t', 'int16_t']
    lscpu_flags: [ 'avx512f', 'avx512bw' ]
    implementation: |
      Vec::base_type result = 0;
      __m512i target_value = _mm512_set1_epi16(val);
      __mmask32 cmp_result = _mm512_cmpeq_epi16_mask(vec, target_value);
      uint32_t mask_bits = static_cast<uint32_t>(cmp_result);
      while (mask_bits != 0) {
        result += mask_bits & 1;
        mask_bits >>= 1;
      }
      return result;
  - target_extension: 'avx512'
    ctype: [ 'uint32_t', 'int32_t', 'uint64_t', 'int64_t']
    lscpu_flags: [ 'avx512f' ]
    implementation: |
      __m512i value = _mm512_set1_epi{{intrin_tp[ctype][1]}}(val);
      __mmask{{intrin_tp[ctype][1]}} cmp_result = _mm512_cmpeq_epi{{intrin_tp[ctype][1]}}_mask(vec, value);
      return _mm_popcnt_u{{intrin_tp[ctype][1]}}(cmp_result);
  - target_extension: 'avx512'
    ctype: [ 'float' ]
    lscpu_flags: [ 'avx512f' ]
    implementation: |
      Vec::base_type result = 0;
      __m512 value = _mm512_set1_ps(val);
      __mmask16 cmp_result = _mm512_cmp_ps_mask(vec, value, _CMP_EQ_OQ);

      uint16_t mask_bits = static_cast<uint16_t>(cmp_result);

      while (mask_bits != 0) {
        result += mask_bits & 1;
        mask_bits >>= 1;
      }
      return result;
  - target_extension: 'avx512'
    ctype: [ 'double' ]
    lscpu_flags: [ 'avx512f' ]
    implementation: |
      Vec::base_type result = 0;
      __m512d value = _mm512_set1_pd(val);
      __mmask8 cmp_result = _mm512_cmp_pd_mask(vec, value, _CMP_EQ_OQ);

      uint8_t mask_bits = static_cast<uint8_t>(cmp_result);

      while (mask_bits != 0) {
        result += mask_bits & 1;
        mask_bits >>= 1;
      }
      return result;
# INTEL - AVX2
  - target_extension: 'avx2'
    ctype: [ 'uint16_t', 'int16_t', 'uint32_t', 'int32_t', 'uint64_t', 'int64_t', 'uint8_t', 'int8_t']
    lscpu_flags: [ 'avx2' ]
    implementation: |
      using T =  Vec::base_type;
      T result = 0;
      {% if ctype != "uint64_t" and ctype != "int64_t" %}
      __m256i value = _mm256_set1_epi{{intrin_tp[ctype][1]}}(val);
      {% else %}
      __m256i value = _mm256_set1_epi{{intrin_tp[ctype][1]}}x(val);
      {% endif %}
      __m256i is_equal = _mm256_cmpeq_epi{{intrin_tp[ctype][1]}}(vec, value);
      T mask[Vec::vector_element_count()];
      _mm256_storeu_si256(reinterpret_cast<__m256i*>(mask), is_equal);

      for (int i = 0; i < Vec::vector_element_count(); i++){
        if(mask[i] == (static_cast<T>(-1))){
          result ++;
        }
      }
      return result;
  - target_extension: 'avx2'
    ctype: [ 'float', 'double' ]
    lscpu_flags: [ 'avx2' ]
    implementation: |
      Vec::base_type result = 0;

      {% if ctype == "float" %}
      __m256 value, is_equal;
      {% else %}
      __m256d value, is_equal;
      {% endif %}

      value = _mm256_set1_{{intrin_tp_full[ctype]}}(val);
      is_equal = _mm256_cmp_{{intrin_tp_full[ctype]}}(vec, value, _CMP_EQ_OQ);
      int mask = _mm256_movemask_{{intrin_tp_full[ctype]}}(is_equal);

      for (int i = 0; i < Vec::vector_element_count(); i++){
        if(mask & (1 << i)){
          result ++;
        }
      }
      return result;
# INTEL - SSE
  - target_extension: 'sse'
    ctype: [ 'uint16_t', 'int16_t', 'uint32_t', 'int32_t', 'uint64_t', 'int64_t']
    lscpu_flags: [ 'sse2', 'sse4_1' ]
    implementation: |
      using T =  Vec::base_type;
      T result = 0;
      {% if ctype != "uint64_t" and ctype != "int64_t" %}
      __m128i value = _mm_set1_epi{{intrin_tp[ctype][1]}}(val);
      {% else %}
      __m128i value = _mm_set1_epi{{intrin_tp[ctype][1]}}x(val);
      {% endif %}
      __m128i is_equal = _mm_cmpeq_epi{{intrin_tp[ctype][1]}}(vec, value);
      T mask[Vec::vector_element_count()];
      _mm_storeu_si128(reinterpret_cast<__m128i*>(mask), is_equal);

      for (int i = 0; i < Vec::vector_element_count(); i++){
        if(mask[i] == (static_cast<T>(-1))){
          result ++;
        }
      }
      return result;
  - target_extension: 'sse'
    ctype: [ 'float', 'double' ]
    lscpu_flags: [ 'sse2', 'sse4_1' ]
    implementation: |
      Vec::base_type result = 0;

      {% if ctype == "float" %}
      __m128 value, is_equal;
      {% else %}
      __m128d value, is_equal;
      {% endif %}

      value = _mm_set1_{{intrin_tp_full[ctype]}}(val);
      is_equal = _mm_cmpeq_{{intrin_tp_full[ctype]}}(vec, value);
      int mask = _mm_movemask_{{intrin_tp_full[ctype]}}(is_equal);

      for (int i = 0; i < Vec::vector_element_count(); i++){
        if(mask & (1 << i)){
          result ++;
        }
      }
      return result;
  - target_extension: 'sse'
    ctype: [ 'uint8_t', 'int8_t']
    lscpu_flags: [ 'sse2' ]
    implementation: |
      Vec::base_type result = 0;
      __m128i value = _mm_set1_epi8(val);
      __m128i is_equal = _mm_cmpeq_epi8(vec, value);
      int mask = _mm_movemask_epi8(is_equal);

      for (int i = 0; i < Vec::vector_element_count(); i++){
        if(mask & (1 << i)){
          result ++;
        }
      }
      return result;
# SCALAR
  - target_extension: 'scalar'
    ctype: [ 'uint8_t', 'uint16_t', 'uint32_t', 'uint64_t', 'int8_t', 'int16_t', 'int32_t', 'int64_t', 'float', 'double' ]
    lscpu_flags: [ ]
    implementation: return (vec == val);
...
