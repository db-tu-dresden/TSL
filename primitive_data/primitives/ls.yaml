---
name: "ls"
description: "Load/Store primitives"
...
---
primitive_name: "load"
brief_description: "Loads data from aligned memory into a vector register."
parameters:
  - ctype: "const typename Vec::base_type*"
    name: "memory"
    description: "Aligned memory which should be transferred into a vector register."
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing the loaded data."
testing:
  - requires: ["storeu"]
    includes: ["<cstddef>", "<cstring>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), true};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
        for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
            reference_result_ptr[j-i] = reference_data_ptr[j];
        }
        auto loaded = load<Vec>(&test_data_ptr[i]);
        storeu<Vec>(test_result_ptr, loaded);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_load_si512(reinterpret_cast<void const *>(assume_aligned<Vec::vector_alignment()>(memory)));"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_load_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void const *>(assume_aligned<Vec::vector_alignment()>(memory)));"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_load_si256(reinterpret_cast<__m256i const *>(assume_aligned<Vec::vector_alignment()>(memory)));"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_load_{{ intrin_tp_full[ctype] }}(assume_aligned<Vec::vector_alignment()>(memory));"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_load_si128(reinterpret_cast<__m128i const *>(assume_aligned<Vec::vector_alignment()>(memory)));"
  - target_extension: "sse"
    ctype: ["float"]
    lscpu_flags: ["sse"]
    implementation: "return _mm_load_ps(assume_aligned<Vec::vector_alignment()>(memory));"
  - target_extension: "sse"
    ctype: ["double"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_load_pd(assume_aligned<Vec::vector_alignment()>(memory));"
#ARM - NEON
  - target_extension: "neon"
    ctype: "int64_t"
    lscpu_flags: ["neon"]
    implementation: "return vld1q_{{ intrin_tp_full[ctype] }}(assume_aligned<Vec::vector_alignment()>(memory));"
#SCALAR
  - target_extension: "scalar"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return *memory;"
#FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      using T = typename Vec::register_type;
      T reg; //initialize the result
      #pragma unroll
      for (size_t idx = 0; idx < Vec::vector_element_count(); idx++) {
        reg[idx] = memory[idx];
      }
      return reg;
...
---
primitive_name: "loadu"
brief_description: "Loads data from (un)aligned memory into a vector register."
parameters:
  - ctype: "const typename Vec::base_type*"
    name: "memory"
    description: "(Un)aligned memory which should be transferred into a vector register."
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing the loaded data."
testing:
  - requires: ["storeu"]
    includes: ["<cstddef>", "<cstring>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); ++i) {
        for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
            reference_result_ptr[j-i] = reference_data_ptr[j];
        }
        auto loaded = loadu<Vec>(&test_data_ptr[i]);
        storeu<Vec>(test_result_ptr, loaded);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_loadu_si512(reinterpret_cast<void const *>(memory));"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_loadu_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void const *>(memory));"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ['avx']
    implementation: "return _mm256_loadu_si256( reinterpret_cast< __m256i const * >( memory ) );"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_loadu_{{ intrin_tp_full[ctype] }}(memory);"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_loadu_si128(reinterpret_cast<__m128i const *>(memory));"
  - target_extension: "sse"
    ctype: ["float"]
    lscpu_flags: ["sse"]
    implementation: "return _mm_loadu_ps(memory);"
  - target_extension: "sse"
    ctype: ["double"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_loadu_pd(memory);"
#ARM - NEON
  - target_extension: "neon"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'neon' ]
    implementation: "return vld1q_{{ intrin_tp_full[ctype] }}(memory);"
#SCALAR
  - target_extension: "scalar"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return *memory;"
#FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      using T = typename Vec::register_type;
      T reg; //initialize the result
      #pragma unroll
      for (size_t idx = 0; idx < Vec::vector_element_count(); idx++) {
        reg[idx] = memory[idx];
      }
      return reg;
...
---
primitive_name: "store"
brief_description: "Stores data from a vector register to aligned memory."
parameters:
  - ctype: "typename Vec::base_type*"
    name: "memory"
    description: "Aligned memory where the data should be stored into."
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Vector containing the data."
testing:
  - requires: ["set1"]
    includes: ["<cstddef>", "<cstring>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), true};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
        for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
            reference_result_ptr[j-i] = i;
        }
        auto loaded = set1<Vec>(i);
        store<Vec>(test_result_ptr, loaded);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_store_si512(reinterpret_cast<void*>(assume_aligned<Vec::vector_alignment()>(memory)), data);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_store_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void*>(assume_aligned<Vec::vector_alignment()>(memory)), data);"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: "_mm256_store_si256(reinterpret_cast<__m256i *>(assume_aligned<Vec::vector_alignment()>(memory)), data);"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "_mm256_store_{{ intrin_tp_full[ctype] }}(assume_aligned<Vec::vector_alignment()>(memory), data);"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "_mm_store_si128(reinterpret_cast<__m128i *>(assume_aligned<Vec::vector_alignment()>(memory)), data);"
  - target_extension: "sse"
    ctype: ["float"]
    lscpu_flags: ["sse"]
    implementation: "_mm_store_ps(assume_aligned<Vec::vector_alignment()>(memory), data);"
  - target_extension: "sse"
    ctype: ["double"]
    lscpu_flags: ["sse2"]
    implementation: "_mm_store_pd(assume_aligned<Vec::vector_alignment()>(memory), data);"
#ARM - NEON
  - target_extension: "neon"
    ctype: "int64_t"
    lscpu_flags: ["neon"]
    implementation: "vst1q_{{ intrin_tp_full[ctype] }}(assume_aligned<Vec::vector_alignment()>(memory), data);"
#SCALAR
  - target_extension: "scalar"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: "*memory = data;"
#FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      #pragma unroll
      for (size_t idx = 0; idx < Vec::vector_element_count(); idx++) {
        memory[idx] = data[idx];
      }
...
---
primitive_name: "storeu"
brief_description: "Stores data from a vector register to (un)aligned memory."
parameters:
  - ctype: "typename Vec::base_type*"
    name: "memory"
    description: "(Un)aligned memory where the data should be stored into."
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Vector containing the data."
testing:
  - requires: ["set1"]
    includes: ["<cstddef>", "<cstring>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), false};
      bool allOk = true;
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
        for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
            reference_result_ptr[j-i] = i;
        }
        auto loaded = set1<Vec>(i);
        storeu<Vec>(test_result_ptr, loaded);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_storeu_si512(reinterpret_cast<void*>(memory), data);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_storeu_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void*>(memory), data);"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: "_mm256_storeu_si256(reinterpret_cast<__m256i *>(memory), data);"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "_mm256_storeu_{{ intrin_tp_full[ctype] }}(memory, data);"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "_mm_storeu_si128(reinterpret_cast<__m128i *>(memory), data);"
  - target_extension: "sse"
    ctype: ["float"]
    lscpu_flags: ["sse"]
    implementation: "_mm_storeu_ps(memory, data);"
  - target_extension: "sse"
    ctype: ["double"]
    lscpu_flags: ["sse2"]
    implementation: "_mm_storeu_pd(memory, data);"
#ARM - NEON
  - target_extension: "neon"
    ctype: "int64_t"
    lscpu_flags: ["neon"]
    implementation: "vst1q_{{ intrin_tp_full[ctype] }}(memory, data);"
#SCALAR
  - target_extension: "scalar"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: "*memory = data;"
#FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      #pragma unroll
      for (size_t idx = 0; idx < Vec::vector_element_count(); idx++) {
        memory[idx] = data[idx];
      }
...
---
primitive_name: "to_array"
brief_description: "Stores SIMD register to array."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Data register."
returns:
  ctype: "__attribute__((__aligned__(Vec::vector_alignment()))) std::array<typename Vec::base_type, Vec::vector_element_count()>"
  description: "Array containing the values from data."
testing:
  - test_name: "default"
    requires: ["loadu"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 1, false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i += Vec::vector_element_count()){
        *reference_result_ptr = Vec::vector_element_count();
        auto vec = loadu<Vec>(&test_data_ptr[i]);
        auto result_arr = to_array<Vec>(vec);

        std::size_t hit = 0;
        for(std::size_t j = 0, k = i; j < Vec::vector_element_count(); j++, k++){
          if(result_arr[j] == reference_data_ptr[k]){
            hit ++;
          }
        }
        *test_result_ptr = hit;
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: |
      alignas(Vec::vector_alignment()) std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      tsl::store<Vec>(assume_aligned<Vec::vector_alignment()>(tmp.data()), data);
      return tmp;
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx2"]
    implementation: |
      alignas(Vec::vector_alignment()) std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      tsl::store<Vec>(assume_aligned<Vec::vector_alignment()>(tmp.data()), data);
      return tmp;
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: ["sse2"]
    implementation: |
      alignas(Vec::vector_alignment()) std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      tsl::store<Vec>(assume_aligned<Vec::vector_alignment()>(tmp.data()), data);
      return tmp;
  #SCALAR
  - target_extension: "scalar"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: |
      std::array<typename Vec::base_type, Vec::vector_element_count()> temp;
      temp.fill(data);
      return temp;
---
primitive_name: "set1"
brief_description: "Broadcasts a single value into all lanes of a vector register."
parameters:
  - ctype: "const typename Vec::base_type"
    name: "value"
    description: "Value which should be broadcasted."
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing the same value in all lanes."
testing:
  - name: "set1"
    includes: ["<cstddef>", "<algorithm>", "<limits>"]
    implementation: |
      std::size_t element_count = 1024;
      bool allOk = true;
      testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), false};
      const std::size_t limit = std::min((std::size_t) 4096, (std::size_t) std::numeric_limits<typename Vec::base_type>::max());
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < limit; ++i) {
        auto vec = set1<Vec>(i);
        for(std::size_t j = 0; j < Vec::vector_element_count(); j++) {
            reference_result_ptr[j] = i;
        }
        allOk &= test_helper.validate_simd_register(vec);
      }
      const auto maxval = std::numeric_limits<typename Vec::base_type>::max();
      auto max_vec = set1<Vec>(maxval);
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        reference_result_ptr[i] = maxval;
      }
      allOk &= test_helper.validate_simd_register(max_vec);
      return allOk;
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_set1_epi{{ intrin_tp[ctype][1] }}(value);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_set1_{{ intrin_tp_full[ctype] }}(value);"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set1_epi{{ intrin_tp[ctype][1] }}(value);"
  - target_extension: "avx2"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set1_epi{{ intrin_tp[ctype][1] }}x(value);"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set1_{{ intrin_tp_full[ctype] }}(value);"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set1_epi{{ intrin_tp[ctype][1] }}(value);"
  - target_extension: "sse"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set1_epi{{ intrin_tp[ctype][1] }}x(value);"
  - target_extension: "sse"
    ctype: ["float"]
    lscpu_flags: ["sse"]
    implementation: "return _mm_set1_ps(value);"
  - target_extension: "sse"
    ctype: ["double"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set1_pd(value);"
#ARM - NEON
  - target_extension: "neon"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'neon' ]
    implementation: "return vdupq_n_{{ intrin_tp_full[ctype] }}( value );"
#SCALAR
  - target_extension: "scalar"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return value;"
#INTEL - FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      using T = typename Vec::register_type;
      T result;
      #pragma unroll
      for(int i = 0; i < Vec::vector_element_count(); ++i) {
        result[i] = value;
      }
      return result;
...
---
primitive_name: "set_zero"
brief_description: "Set all lanes to zero."
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing 0 in all lanes."
testing:
  - test_name: "default"
    requires: ["set1"]
    implementation: |
      using T = typename Vec::base_type;
      testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), Vec::vector_element_count(), false};
      bool allOk = true;
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();
      auto vec = set_zero<Vec>();
      storeu<Vec>(test_result_ptr, vec);
      for (size_t i = 0; i < Vec::vector_element_count(); ++i) {
        reference_result_ptr[i] = (T)0;
      }
      test_helper.synchronize();
      return test_helper.validate();
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_setzero_si512();"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_setzero_{{ intrin_tp_full[ctype] }}();"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_setzero_si256();"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_setzero_{{ intrin_tp_full[ctype] }}();"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_setzero_si128();"
  - target_extension: "sse"
    ctype: ["float", "double"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_setzero_{{ intrin_tp_full[ctype] }}();"
#FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "float", "uint64_t", "int64_t", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: |
      using T = typename Vec::register_type;
      T result; //initialize the result
      #pragma unroll
      for(int i = 0; i < Vec::vector_element_count(); ++i) {
        result[i] = 0;
      }
      return result;
  #SCALAR
  - target_extension: ["scalar"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: return 0;
---
primitive_name: "set"
brief_description: "Transfers provided elements into a vector register."
parameters:
  - ctype: "Ts"
    name: "args"
    description: "Values which should be transferred."
    is_parameter_pack: True
returns:
  ctype: "typename Vec::register_type"
  description: "Vector register containing the values."
testing:
  - requires: ["storeu"]
    includes: ["<cstddef>", "<algorithm>", "<limits>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
        for(size_t j = i; j < i + Vec::vector_element_count(); ++j) {
            reference_result_ptr[j-i] = reference_data_ptr[j];
        }
        auto loaded = testing::set_call_helper_t<Vec>::call_set(&test_data_ptr[i]);
        storeu<Vec>(test_result_ptr, loaded);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_set_epi{{ intrin_tp[ctype][1] }}(args...);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_set_{{ intrin_tp_full[ctype] }}(args...);"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set_epi{{ intrin_tp[ctype][1] }}(args...);"
  - target_extension: "avx2"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set_epi64x( args... );"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_set_{{ intrin_tp_full[ctype] }}(args...);"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "int8_t", "int16_t", "int32_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set_epi{{ intrin_tp[ctype][1] }}(args...);"
  - target_extension: "sse"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set_epi{{ intrin_tp[ctype][1] }}x(args...);"
  - target_extension: "sse"
    ctype: ["float"]
    lscpu_flags: ["sse"]
    implementation: "return _mm_set_{{ intrin_tp_full[ctype] }}(args...);"
  - target_extension: "sse"
    ctype: ["double"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_set_{{ intrin_tp_full[ctype] }}(args...);"
  #SCALAR
  - target_extension: "scalar"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return std::get<0>(std::make_tuple(args...));"
...
---
primitive_name: "sequence"
brief_description: "Creates a sequence [0..SIMD-Reg-Element-Count]."
returns:
  ctype: "typename Vec::register_type"
  description: "Vector register containing the sequence."
testing:
  - test_name: "default"
    requires: ["loadu", "storeu"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t count = Vec::vector_element_count();

      testing::test_memory_helper_t<Vec> test_helper{1, count, false};
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();

      typename Vec::base_type data[count];
      for(std::size_t i = 0; i < count; i++){
        data[i] = i;
      }
      auto vec = loadu<Vec>(data);
      storeu<Vec>(reference_result_ptr, vec);

      auto vec_test = sequence<Vec>();
      storeu<Vec>(test_result_ptr, vec_test);

      test_helper.synchronize();
      return test_helper.validate();
definitions:
#  INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        std::integer_sequence<sequence_type, Is...>
      ) {
        return tsl::set<Vec>(
          (T)(((T)(sizeof...(Is) - 1 - Is)))...
        );
      };
      return seq_fun(std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        std::integer_sequence<sequence_type, Is...>
      ) {
        return tsl::set<Vec>(
          (T)(((T)(sizeof...(Is) - 1 - Is)))...
        );
      };
      return seq_fun(std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #INTEL - SSE
  - target_extension: "sse"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: ["sse2"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        std::integer_sequence<sequence_type, Is...>
      ) {
        return tsl::set<Vec>(
          (T)(((T)(sizeof...(Is) - 1 - Is)))...
        );
      };
      return seq_fun(std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: []
    implementation: "return 0;"
...
---
primitive_name: "custom_sequence"
brief_description: "Creates a sequence."
parameters:
  - ctype: "typename Vec::base_type"
    name: "start"
    description: "Start value for sequence."
    default_value: "0"
  - ctype: "typename Vec::base_type"
    name: "stepwidth"
    description: "Stepwidth."
    default_value: "1"
    declaration_attributes: "[[maybe_unused]]"
returns:
  ctype: "typename Vec::register_type"
  description: "Vector register containing the sequence."
testing:
  - test_name: "default"
    requires: ["to_array"]
    includes: ["<cmath>"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;

      testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
      auto reference_data_ptr = test_helper.data_ref();
      auto test_data_ptr = test_helper.data_target();

      bool allOk = true;
      for(std::size_t i = 0; i < element_count - 1; i++) {
        auto vec = custom_sequence<Vec>(test_data_ptr[i], test_data_ptr[i+1]);
        auto test_arr = to_array<Vec>(vec);
        T data [Vec::vector_element_count()];

        if constexpr (std::is_integral<T>::value){
          std::size_t idx = 0;
          for(T j = reference_data_ptr[i]; idx < Vec::vector_element_count(); j+= reference_data_ptr[i+1]){
            data[idx++] = j;
          }
          for(std::size_t l = 0; l < Vec::vector_element_count(); l++){
            allOk &= (data[l] == test_arr[l]);
          }
        }else{
          // Kahan sum alg
          T sum = reference_data_ptr[i], c = 0.0;
          data[0] = reference_data_ptr[i];
          std::size_t idx = 1;
          while(idx < Vec::vector_element_count()){
            T y  = reference_data_ptr[i+1] - c;
            T t = sum + y;
            c = (t - sum) - y;
            sum = t;
            data[idx++] = sum;
          }
          for(std::size_t l = 0; l < Vec::vector_element_count(); l++){
            // Checking with Tolerance
            allOk &= (std::fabs(data[l] - test_arr[l]) < 1e-3);
          }
        }
      }
      return allOk;
definitions:
  #  INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        T const init, T const sw, std::integer_sequence<sequence_type, Is...>
      ) {
        return tsl::set<Vec>(
          (T)((((T)(sizeof...(Is) - 1 - Is))*sw)+init)...
        );
      };
      return seq_fun(start, stepwidth, std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        T const init, T const sw, std::integer_sequence<sequence_type, Is...>
      ) {
        return tsl::set<Vec>(
          (T)((((T)(sizeof...(Is) - 1 - Is))*sw)+init)...
        );
      };
      return seq_fun(start, stepwidth, std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #INTEL - SSE
  - target_extension: "sse"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: ["sse2"]
    implementation: |
      using T = typename Vec::base_type;
      using sequence_type = typename std::conditional_t<std::is_integral_v<T>, T, uint64_t>;
      auto seq_fun= []<sequence_type... Is>(
        T const init, T const sw, std::integer_sequence<sequence_type, Is...>
      ) {
        return tsl::set<Vec>(
          (T)((((T)(sizeof...(Is) - 1 - Is))*sw)+init)...
        );
      };
      return seq_fun(start, stepwidth, std::make_integer_sequence<sequence_type, Vec::vector_element_count()>());
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double" ]
    lscpu_flags: []
    implementation: "return start;"
...
---
primitive_name: "gather"
brief_description: "Transfers data from arbitrary locations into a vector register."
additional_simd_template_parameter:
  name: "IndicesType"
  default_value:  "typename Vec::offset_register_type"
additional_non_specialized_template_parameters:
  - ctype: "int"
    name: "N"
    default_value: "sizeof(typename Vec::base_type)"
parameters:
  - ctype: "const void*"
    name: "memory"
    description: "(Start)pointer of the memory (which is used as base for address calculation)."
  - ctype: "const typename IndicesType::register_type"
    name: "index"
    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
  - ctype: "std::integral_constant<int, N>"
    name: "scale"
    description: "Scale."
    default_value: std::integral_constant<int, sizeof(typename Vec::base_type)>{}
    declaration_attributes: "[[maybe_unused]]"
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing gathered data."
testing:
  - requires: ["storeu", "loadu"]
    includes: ["<cstddef>", "<algorithm>", "<limits>", "<type_traits>"]
    implementation: |
      constexpr size_t test_mem_size = 256;
      constexpr size_t test_mem_offset = test_mem_size / 2;
      constexpr size_t iteration_count = 16;
      testing::test_memory_helper_t<Vec> test_helper{test_mem_size, Vec::vector_element_count(), true, testing::seq_init_start_0<typename Vec::base_type>};
      testing::test_memory_helper_t<IndicesType> test_helper_indices{
          iteration_count * Vec::vector_element_count(), 0, true,
          testing::rnd_init_bounded<typename IndicesType::base_type>,
          (typename IndicesType::base_type)(std::is_signed_v<typename IndicesType::base_type> ? -test_mem_offset : 0),
          (typename IndicesType::base_type)(test_mem_offset - 1)
      };
      for(size_t i = 0; i < iteration_count; i++) {
          for(size_t j = 0; j < Vec::vector_element_count(); j++) {
              test_helper.result_ref()[j] = test_helper.data_ref()[test_helper_indices.data_ref()[i * Vec::vector_element_count() + j] + test_mem_offset];
          }
          auto indices = loadu<IndicesType>(test_helper_indices.data_target() + (i * Vec::vector_element_count()));
          auto result = gather<Vec, IndicesType>(test_helper.data_target() + test_mem_offset, indices);
          store<Vec>(test_helper.result_target(), result);
          test_helper.synchronize();
          if (!test_helper.validate()) return false;
      }
      return true;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    additional_simd_template_extension: "avx512"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    additional_simd_template_base_type_mapping_dict: {
      "uint32_t": ["int32_t", "uint32_t"],
      "int32_t":  ["int32_t", "uint32_t"],
      "float":    ["int32_t", "uint32_t"],
      "uint64_t": ["int64_t", "uint64_t"],
      "int64_t":  ["int64_t", "uint64_t"],
      "double":   ["int64_t", "uint64_t"],
    }
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_i{{ intrin_tp[additional_simd_template_base_type][1] }}gather_{{ intrin_tp_full[ctype].replace('epu', 'epi') }}(index, memory, N);"
  #INTEL - AVX512 / AVX2
  - target_extension: "avx512"
    additional_simd_template_extension: "avx2"
    ctype: ["uint64_t", "int64_t", "double"]
    additional_simd_template_base_type_mapping_dict: {
      "uint64_t": ["int32_t", "uint32_t"],
      "int64_t":  ["int32_t", "uint32_t"],
      "double":   ["int32_t", "uint32_t"],
    }
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_i{{ intrin_tp[additional_simd_template_base_type][1] }}gather_{{ intrin_tp_full[ctype].replace('epu', 'epi') }}(index, memory, N);"
  #INTEL - SSE
  - target_extension: "sse"
    additional_simd_template_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    additional_simd_template_base_type_mapping_dict: {
      "int8_t":   ["int8_t", "uint8_t"],
      "uint8_t":  ["int8_t", "uint8_t"],
      "int16_t":  ["int16_t", "uint16_t"],
      "uint16_t": ["int16_t", "uint16_t"],
      "int32_t":  ["int32_t", "uint32_t"],
      "uint32_t": ["int32_t", "uint32_t"],
      "float":    ["int32_t", "uint32_t"],
      "int64_t":  ["int64_t", "uint64_t"],
      "uint64_t": ["int64_t", "uint64_t"],
      "double":   ["int64_t", "uint64_t"],
    }
    lscpu_flags: ['sse2']
    is_native: False
    implementation: |
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> result{};
      auto const idx_array = tsl::to_array<IndicesType>(index);
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
          result[i] = *reinterpret_cast<typename Vec::base_type const *>(reinterpret_cast<char const*>(memory) + idx_array[i] * N);
      }
      return tsl::load<Vec>(result.data());
  #ARM - NEON
  - target_extension: "neon"
    additional_simd_template_extension: "neon"
    ctype: "int64_t"
    lscpu_flags: [ 'neon' ]
    is_native: False
    implementation: >
      auto mem = reinterpret_cast<typename Vec::base_type const *>(memory);
      auto tmp = vdupq_n_s64( ( mask[ 0 ] == 0 ) ? source[ 0 ] : mem[ index[ 0 ][ 0 ] ] );
      return vsetq_lane_s64( ( ( mask[ 1 ] == 0 ) ? source[ 1 ] : mem[ index[ 0 ][ 1 ] ] ), tmp, 1 );
  #SCALAR
  - target_extension: "scalar"
    additional_simd_template_extension: "scalar"
    additional_simd_template_base_type_mapping_dict: {
      "int8_t":   ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"],
      "uint8_t":  ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"],
      "int16_t":  ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"],
      "uint16_t": ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"],
      "int32_t":  ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"],
      "uint32_t": ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"],
      "int64_t":  ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"],
      "uint64_t": ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"],
      "float":    ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"],
      "double":   ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"],
    }
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
    lscpu_flags: [ ]
    implementation: "return *reinterpret_cast<typename Vec::base_type const *>(reinterpret_cast<const char*>(memory) + index * N);"
...
---
primitive_name: "gather"
functor_name: "mask_gather"
additional_simd_template_parameter:
  name: "IndicesType"
  default_value: "typename Vec::offset_register_type"
brief_description: "If mask[i] is 1, load memory[index[i] * scale], otherwise use source[i]"
additional_non_specialized_template_parameters:
  - ctype: "int"
    name: "N"
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "mask"
    description: "Mask indicating which lanes should be gathered."
  - ctype: "const typename Vec::register_type"
    name: "source"
    description: "Vector register containing values which should be preserved depending on the mask (if mask[i] == 0)."
  - ctype: "const void*"
    name: "memory"
    description: "(Start)pointer of the memory (which is used as base for address calculation)."
  - ctype: "const typename IndicesType::offset_base_register_type"
    name: "index"
    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
  - ctype: "std::integral_constant<int, N>"
    name: "scale"
    description: "Scale."
    declaration_attributes: "[[maybe_unused]]"
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing gathered data."
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    additional_simd_template_extension: "avx512"
    ctype: ["uint32_t", "uint64_t", "int32_t", "int64_t"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_mask_i{{ intrin_tp[ctype][1] }}gather_epi{{ intrin_tp[ctype][1] }}(source, mask, index, memory, N);"
  - target_extension: "avx512"
    additional_simd_template_extension: "avx512"
    ctype: ["float"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_mask_i32gather_ps(source, mask, index, memory, N);"
  - target_extension: "avx512"
    additional_simd_template_extension: "avx512"
    ctype: ["double"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_mask_i64gather_pd(source, mask, index, memory, N);"
  #INTEL - AVX2
  - target_extension: "avx2"
    additional_simd_template_extension: "avx2"
    ctype: ["uint64_t", "int64_t"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i64gather_epi64(source, reinterpret_cast<long long int const *>(memory), index, mask, N);"
  - target_extension: "avx2"
    additional_simd_template_extension: "avx2"
    ctype: ["uint32_t", "int32_t"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i32gather_epi32(source, reinterpret_cast<int const *>(memory), index, mask, N);"
  - target_extension: "avx2"
    additional_simd_template_extension: "avx2"
    ctype: ["float"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i32gather_ps(source, reinterpret_cast<float const *>(memory), index, mask, N);"
  - target_extension: "avx2"
    additional_simd_template_extension: "avx2"
    ctype: ["double"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_mask_i64gather_pd(source, reinterpret_cast<double const *>(memory), index, mask, N);"
  #INTEL - SSE
  - target_extension: "sse"
    additional_simd_template_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'sse2' ]
    is_native: False
    implementation: |
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> result{};
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tsl::to_array<offsetExt>(index);
      auto const src_array = tsl::to_array<Vec>(source);
      auto const mask_array = tsl::to_array<Vec>(mask);
      if constexpr(N == 1) {
        auto mem = reinterpret_cast<char const*>(memory);
        for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
          result[i] = (mask_array[i] == 0) ? src_array[i] : mem[idx_array[i]];
        }
      } else {
        if constexpr(N == sizeof(typename Vec::base_type)) {
          auto mem = reinterpret_cast<typename Vec::base_type const *>(memory);
          for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
            result[i] = (mask_array[i] == 0) ? src_array[i] : mem[idx_array[i]];
          }
        } else {
          auto mem = reinterpret_cast<char const*>(memory);
          for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
            result[i] = (mask_array[i] == 0) ? src_array[i] : mem[idx_array[i]*N];
          }
        }
      }
      return tsl::load<Vec>(result.data());
  #ARM - NEON
  - target_extension: "neon"
    additional_simd_template_extension: "neon"
    ctype: "int64_t"
    lscpu_flags: [ 'neon' ]
    is_native: False
    implementation: |
      auto mem = reinterpret_cast<typename Vec::base_type const *>(memory);
      auto tmp = vdupq_n_s64( ( mask[ 0 ] == 0 ) ? source[ 0 ] : mem[ index[ 0 ][ 0 ] ] );
      return vsetq_lane_s64( ( ( mask[ 1 ] == 0 ) ? source[ 1 ] : mem[ index[ 0 ][ 1 ] ] ), tmp, 1 );
  #SCALAR
  - target_extension: "scalar"
    additional_simd_template_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
    lscpu_flags: [ ]
    implementation: "return (mask&1)==1 ? reinterpret_cast<typename Vec::base_type const *>(memory)[index] : source;"
...
---
primitive_name: "scatter"
brief_description: "Transfers data from a vector register to an arbitrary locations."
additional_non_specialized_template_parameters:
  - ctype: "int"
    name: "N"
parameters:
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Vector register containing values which should be scattered to memory."
  - ctype: "void*"
    name: "memory"
    description: "(Start)pointer of the memory (which is used as base for address calculation)."
  - ctype: "const typename Vec::offset_base_register_type"
    name: "index"
    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
  - ctype: "std::integral_constant<int, N>"
    name: "scale"
    description: "Scale."
    declaration_attributes: "[[maybe_unused]]"
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: |
      _mm512_i{{ intrin_tp[ctype][1] }}scatter_epi{{ intrin_tp[ctype][1] }}(
         memory, index, data, N
      );
  - target_extension: "avx512"
    ctype: ["float"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_i32scatter_ps(memory, index, data, N);"
  - target_extension: "avx512"
    ctype: ["double"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_i64scatter_pd(memory, index, data, N);"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx2"]
    is_native: False
    includes: ["<array>"]
    implementation: |
      auto const val_array = tsl::to_array<Vec>(data);
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tsl::to_array<offsetExt>(index);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if constexpr(N==sizeof(typename Vec::base_type)) {
          auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
          mem[idx_array[i]] = val_array[i];
        } else {
          if constexpr(N==1) {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
          } else {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
          }
        }
      }
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'sse2' ]
    includes: ["<array>"]
    is_native: False
    implementation: |
      auto const val_array = tsl::to_array<Vec>(data);
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tsl::to_array<offsetExt>(index);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if constexpr(N==sizeof(typename Vec::base_type)) {
          auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
          mem[idx_array[i]] = val_array[i];
        } else {
          if constexpr(N==1) {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
          } else {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
          }
        }
      }
  #ARM - NEON
  - target_extension: "neon"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'neon' ]
    includes: ["<array>"]
    is_native: False
    implementation: |
      auto const val_array = tsl::to_array<Vec>(data);
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tsl::to_array<offsetExt>(index);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(mask_array[i] != 0) {
        if constexpr(N==sizeof(typename Vec::base_type)) {
          auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
          mem[idx_array[i]] = val_array[i];
        } else {
          if constexpr(N==1) {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
          } else {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
          }
        }
      }
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
    lscpu_flags: [ ]
    implementation: |
      if constexpr(N==sizeof(typename Vec::base_type)) {
        auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
        mem[index] = data;
      } else {
        if constexpr(N==1) {
          *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[index]) = data;
        } else {
          *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(index<<(cilog2(N)))]) = data;
        }
      }
...
---
primitive_name: "scatter"
functor_name: "mask_scatter"
brief_description: "Transfers data from a vector register to an arbitrary locations."
additional_non_specialized_template_parameters:
  - ctype: "int"
    name: "N"
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "mask"
    description: "Mask indicating which lanes should be scattered."
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Vector register containing values which should be scattered to memory."
  - ctype: "void*"
    name: "memory"
    description: "(Start)pointer of the memory (which is used as base for address calculation)."
  - ctype: "const typename Vec::offset_base_register_type"
    name: "index"
    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
  - ctype: "std::integral_constant<int, N>"
    name: "scale"
    description: "Scale."
    declaration_attributes: "[[maybe_unused]]"
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: |
      _mm512_mask_i{{ intrin_tp[ctype][1] }}scatter_epi{{ intrin_tp[ctype][1] }}(
         memory, mask, index, data, N
      );
  - target_extension: "avx512"
    ctype: ["float"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_mask_i32scatter_ps(memory, mask, index, data, N);"
  - target_extension: "avx512"
    ctype: ["double"]
    lscpu_flags: ["avx512f"]
    implementation: "_mm512_mask_i64scatter_pd(memory, mask, index, data, N);"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx2"]
    is_native: False
    includes: ["<array>"]
    implementation: |
      auto const val_array = tsl::to_array<Vec>(data);
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tsl::to_array<offsetExt>(index);
      auto const mask_array = tsl::to_array<Vec>(mask);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(mask_array[i] != 0) {
          if constexpr(N==sizeof(typename Vec::base_type)) {
            auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
            mem[idx_array[i]] = val_array[i];
          } else {
            if constexpr(N==1) {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
            } else {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
            }
          }
        }
      }
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'sse2' ]
    includes: ["<array>"]
    is_native: False
    implementation: |
      auto const val_array = tsl::to_array<Vec>(data);
      using offsetExt = typename Vec::transform_extension<Vec::offset_base_type>;
      auto const idx_array = tsl::to_array<offsetExt>(index);
      auto const mask_array = tsl::to_array<Vec>(mask);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(mask_array[i] != 0) {
          if constexpr(N==sizeof(typename Vec::base_type)) {
            auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
            mem[idx_array[i]] = val_array[i];
          } else {
            if constexpr(N==1) {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
            } else {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
            }
          }
        }
      }
  #ARM - NEON
  - target_extension: "neon"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: [ 'neon' ]
    includes: ["<array>"]
    is_native: False
    implementation: |
      alignas(Vec::vector_size_B()) std::array<typename Vec::offset_base_type, Vec::vector_element_count()> idx_array{};
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> val_array{};
      alignas(Vec::vector_size_B()) std::array<typename Vec::base_type, Vec::vector_element_count()> mask_array{};
      tsl::store<Vec>(val_array.data(), data);
      tsl::store<typename Vec::transform_extension<Vec::offset_base_type>>(idx_array.data(), index);
      tsl::store<Vec>(mask_array.data(), mask);
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(mask_array[i] != 0) {
          if constexpr(N==sizeof(typename Vec::base_type)) {
            auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
            mem[idx_array[i]] = val_array[i];
          } else {
            if constexpr(N==1) {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[idx_array[i]]) = val_array[i];
            } else {
              *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(idx_array[i]<<(cilog2(N)))]) = val_array[i];
            }
          }
        }
      }
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double" ]
    lscpu_flags: [ ]
    implementation: |
      if((mask&0b1) != 0) {
        if constexpr(N==sizeof(typename Vec::base_type)) {
          auto mem = reinterpret_cast<typename Vec::base_type *>(memory);
          mem[index] = data;
        } else {
          if constexpr(N==1) {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[index]) = data;
          } else {
            *reinterpret_cast<typename Vec::base_type*>(&reinterpret_cast<uint8_t*>(memory)[(index<<(cilog2(N)))]) = data;
          }
        }
      }
...
#---
#primitive_name: "gather"
#additional_simd_template_parameter:
#  name: "OffsetType"
#brief_description: "Transfers data from arbitrary locations into a vector register."
#additional_non_specialized_template_parameters:
#  - ctype: "int"
#    name: "N"
#parameters:
#  - ctype: "const typename Vec::base_type *"
#    attributes: "__restrict__"
#    name: "memory"
#    description: "(Start)pointer of the memory (which is used as base for address calculation)."
#  - ctype: "const std::array<typename OffsetType::register_type, sizeof(typename OffsetType::base_type)/sizeof(Vec::base_type)> &"
#    name: "indices"
#    description: "Offsets array containing simd<offset_t, EXTENSION> register_types containing relative offsets to the start pointer (the number of array elements depend on the sizeof(offset_type)/sizeof(base_type) ratio, where sizeof(offset_type) should be 8)."
#  - ctype: "std::integral_constant<int, N>"
#    name: "scale"
#    description: "Scale."
#returns:
#  ctype: "typename Vec::register_type"
#  description: "Vector containing gathered data."
#definitions:
##INTEL - AVX2
#  - target_extension: "avx2"
#    ctype: ["uint8_t", "int8_t"]
#    additional_simd_template_base_type: ["uint32_t"]
#    lscpu_flags: ['avx2']
#    implementation: |
#      auto base_addr = reinterpret_cast<int const*>(memory);
#      _mm256_i32gather_epi32(base_addr, indices[0], N);
#      return _mm512_mask_i64gather_epi64( source, mask, index[0], reinterpret_cast< void const * >( memory ), N );
#...
---
primitive_name: "compress_store"
brief_description: "Stores elements from data consecutively, if the corresponding bit in mask is set to 1."
parameters:
  - ctype: "const typename Vec::imask_type"
    name: "mask"
    description: "Mask"
  - ctype: "typename Vec::base_type*"
    name: "memory"
    description: "Memory"
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Data"
testing:
  - test_name: "full_mask"
    requires: ["loadu"]
    implementation: |
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      typename Vec::imask_type mask = -1;
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i += Vec::vector_element_count()){
        auto vec_a = loadu<Vec>(&reference_data_ptr[i]);
        storeu<Vec>(reference_result_ptr, vec_a);

        auto vec_b = loadu<Vec>(&test_data_ptr[i]);
        compress_store<Vec>(mask, test_result_ptr, vec_b);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
  - test_name: "no_mask"
    requires: ["storeu", "set1"]
    implementation: |
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
      bool allOk = true;
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      typename Vec::imask_type mask = 0;
      auto zero_vec = set1<Vec>(0);
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i += Vec::vector_element_count()){
        storeu<Vec>(reference_result_ptr, zero_vec);
        storeu<Vec>(test_result_ptr, zero_vec);

        auto vec = loadu<Vec>(&test_data_ptr[i]);
        compress_store<Vec>(mask, test_result_ptr, vec);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: [ "uint32_t", "int32_t", "uint64_t", "int64_t" ]
    lscpu_flags: [ "avx512f"]
    implementation: "_mm512_mask_compressstoreu_epi{{ intrin_tp[ctype][1] }}(reinterpret_cast<void*>(memory), mask, data);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: [ "avx512f" ]
    implementation: "_mm512_mask_compressstoreu_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void*>(memory), mask, data);"
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t"]
    lscpu_flags: ["avx512f", "avx512vbmi2"]
    implementation: "_mm512_mask_compressstoreu_epi{{ intrin_tp[ctype][1] }}(reinterpret_cast<void*>(memory), mask, data);"
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ["avx512f"]
    includes: ["<cstring>"]
    is_native: False
    implementation: |
      auto const orig_mem = memory;
      auto const data_array = tsl::to_array<Vec>(data);
      typename Vec::base_type safe[Vec::vector_element_count()];
      std::memcpy(reinterpret_cast<void*>(safe), reinterpret_cast<void const *>(memory), Vec::vector_size_B());
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        *memory = data_array[i];
        memory += (mask>>i)&0b1;
      }
      if(((mask>>(Vec::vector_element_count()-1))&0b1) == 0) {
        *memory = safe[memory-orig_mem];
      }
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx2"]
    includes: ["<cstring>"]
    is_native: False
    implementation: |
      auto const orig_mem = memory;
      auto const data_array = tsl::to_array<Vec>(data);
      typename Vec::base_type safe[Vec::vector_element_count()];
      std::memcpy(reinterpret_cast<void*>(safe), reinterpret_cast<void const *>(memory), Vec::vector_size_B());
      #pragma unroll
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        *memory = data_array[i];
        memory += (mask>>i)&0b1;
      }
      if(((mask>>(Vec::vector_element_count()-1))&0b1) == 0) {
        *memory = safe[memory-orig_mem];
      }
  - target_extension: "avx2"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx2", "avx512f", "avx512vl"]
    implementation: "_mm256_mask_compressstoreu_epi{{ intrin_tp[ctype][1] }}(reinterpret_cast<void*>(memory), mask, data);"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx2", "avx512f", "avx512vl"]
    implementation: "_mm256_mask_compressstoreu_{{ intrin_tp_full[ctype] }}(reinterpret_cast<void*>(memory), mask, data);"
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t"]
    lscpu_flags: ["avx2", "avx512f", "avx512vbmi2", "avx512vl"]
    implementation: "_mm256_mask_compressstoreu_epi{{ intrin_tp[ctype][1] }}(reinterpret_cast<void*>(memory), mask, data);"
  #INTEL - SSE
  - target_extension: ["sse"]
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    is_native: False
    lscpu_flags: ["sse2"]
    implementation: |
      auto const data_array = tsl::to_array<Vec>(data);

      for(std::size_t i = 0; i < Vec::vector_element_count(); i++){
        if((mask >> i) & 1){
          *memory = data_array[i];
          memory ++;
        }
      }
  #SCALAR
  - target_extension: "scalar"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: |
      if(mask){
        *memory = data;
      }
...
---
primitive_name: "expand_load"
brief_description: "Loads contiguos data from a specified memory location and puts the elements using write mask."
parameters:
  - ctype: "const typename Vec::imask_type"
    name: "mask"
    description: "Mask"
  - ctype: "const typename Vec::register_type"
    name: "src"
    description: "Source register. Data is kept if corresponding mask bit is set to 0."
  - ctype: "typename Vec::base_type*"
    name: "memory"
    description: "Memory"
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing the elements."
testing:
  - test_name: "full_mask"
    requires: ["storeu", "set1"]
    implementation: |
      std::size_t element_count = 2048;
      testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      auto offset = 1024;
      typename Vec::imask_type mask = -1;
      auto zero_vec = set1<Vec>(0);
      for(std::size_t i = 0; i < (element_count/2) - Vec::vector_element_count(); i += Vec::vector_element_count()){
        auto mem_ref = loadu<Vec>(&reference_data_ptr[i + offset]);
        storeu<Vec>(reference_result_ptr, mem_ref);
        auto src_test = loadu<Vec>(&test_data_ptr[i]);
        auto result = expand_load<Vec>(mask, src_test, &test_data_ptr[i+offset]);
        storeu<Vec>(test_result_ptr, result);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
  - test_name: "no_mask"
    requires: ["storeu", "set1"]
    implementation: |
      std::size_t element_count = 2048;
      testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      auto offset = 1024;
      typename Vec::imask_type mask = 0;
      auto zero_vec = set1<Vec>(0);
      for(std::size_t i = 0; i < (element_count/2) - Vec::vector_element_count(); i += Vec::vector_element_count()){
        auto mem_ref = loadu<Vec>(&reference_data_ptr[i]);
        storeu<Vec>(reference_result_ptr, mem_ref);
        auto src_test = loadu<Vec>(&test_data_ptr[i]);
        auto result = expand_load<Vec>(mask, src_test, &test_data_ptr[i+offset]);
        storeu<Vec>(test_result_ptr, result);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
  - test_name: "default"
    requires: ["storeu", "loadu"]
    includes: ["<random>", "<limits>"]
    implementation: |
      using mask_t = typename Vec::imask_type;

      // Generate random Mask
      std::random_device rd;
      std::mt19937 gen(rd());
      std::uniform_int_distribution<mask_t> dist(std::numeric_limits<mask_t>::min(), std::numeric_limits<mask_t>::max());
      mask_t mask = dist(gen);

      std::size_t element_count = 2048;
      testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      auto offset = 1024;
      for(std::size_t i = 0; i < (element_count/2) - Vec::vector_element_count(); i += Vec::vector_element_count()){
        typename Vec::base_type data[Vec::vector_element_count()];
        for(std::size_t j = 0, k = i, l = i; j < Vec::vector_element_count(); j++, k++){
          ((mask >> j) & 0b1)? data[j] = reference_data_ptr[offset + l++] : data[j] = reference_data_ptr[k];
        }
        auto temp = loadu<Vec>(data);
        storeu<Vec>(reference_result_ptr, temp);
        auto result = expand_load<Vec>(mask, loadu<Vec>(&test_data_ptr[i]), &test_data_ptr[i + offset]);
        storeu<Vec>(test_result_ptr, result);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: [ "uint32_t", "int32_t", "uint64_t", "int64_t" ]
    lscpu_flags: [ "avx512f" ]
    implementation: "return _mm512_mask_expandloadu_epi{{ intrin_tp[ctype][1] }}(src, mask, reinterpret_cast<void*>(memory));"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: [ "avx512f" ]
    implementation: "return _mm512_mask_expandloadu_{{ intrin_tp_full[ctype] }}(src, mask, reinterpret_cast<void*>(memory));"
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t"]
    lscpu_flags: ["avx512f", "avx512vbmi2"]
    implementation: "return _mm512_mask_expandloadu_epi{{ intrin_tp[ctype][1] }}(src, mask, reinterpret_cast<void*>(memory));"
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ["avx512f"]
    includes: ["<cstring>"]
    is_native: False
    implementation: |
      //@todo: optimizable
      alignas(Vec::vector_alignment()) std::array<typename Vec::base_type, Vec::vector_element_count()> data_array;
      auto src_array = tsl::to_array<Vec>(src);
      auto mem = memory;
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(((mask>>i)&0b1)==0) {
          data_array[i] = src_array[i];
        } else {
          data_array[i] = *mem;
          ++mem;
        }
      }
      return _mm512_load_si512(reinterpret_cast<void const *>(data_array.data()));
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "uint32_t", "int32_t", "uint64_t", "int64_t", "float", "double"]
    lscpu_flags: ["avx2"]
    includes: ["<cstring>"]
    is_native: False
    implementation: |
      //@todo: optimizable
      alignas(Vec::vector_alignment()) std::array<typename Vec::base_type, Vec::vector_element_count()> data_array;
      auto src_array = tsl::to_array<Vec>(src);
      auto mem = memory;
      for(std::size_t i = 0; i < Vec::vector_element_count(); ++i) {
        if(((mask>>i)&0b1)==0) {
          data_array[i] = src_array[i];
        } else {
          data_array[i] = *mem;
          ++mem;
        }
      }
      return tsl::load<Vec>(data_array.data());
      //return _mm256_load_si256(reinterpret_cast<__m256i const *>(data_array.data()));
  - target_extension: "avx2"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx2", "avx512f", "avx512vl"]
    implementation: "return _mm256_mask_expandloadu_epi{{ intrin_tp[ctype][1] }}(src, mask, reinterpret_cast<void const*>(memory));"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx2", "avx512f", "avx512vl"]
    implementation: "return _mm256_mask_expandloadu_{{ intrin_tp_full[ctype] }}(src, mask, reinterpret_cast<void const *>(memory));"
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t"]
    lscpu_flags: ["avx2", "avx512f", "avx512vbmi2", "avx512vl"]
    implementation: "return _mm256_mask_expandloadu_epi{{ intrin_tp[ctype][1] }}(src, mask, reinterpret_cast<void const*>(memory));"
...
---
primitive_name: "load_convert_up"
additional_simd_template_parameter:
  name: "ToType"
parameters:
  - ctype: "typename Vec::base_type const *"
    name: "memory"
    description: "Memory"
returns:
  ctype: "typename ToType::register_type"
  description: "Vector containing the data."
definitions:
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: [ "uint8_t", "uint16_t", "uint32_t" ]
    additional_simd_template_base_type_mapping_dict: { "uint8_t": ["uint16_t", "uint32_t", "uint64_t", "int16_t", "int32_t", "int64_t"], "uint16_t": ["uint32_t", "uint64_t", "int32_t", "int64_t"], "uint32_t": ["uint64_t", "int64_t"]}
    lscpu_flags: ["sse2", "avx2"]
    is_native: False
    implementation: |
      return
        _mm256_and_si256(
          tsl::set1<ToType>(
            (typename Vec::base_type)~0
          ),
          _mm256_cvtepi{{ intrin_tp[ctype][1] }}_epi{{ intrin_tp[additional_simd_template_base_type][1] }}(
            _mm_loadu_si128(reinterpret_cast<__m128i const *>(memory))
          )
        );
  - target_extension: "avx2"
    ctype: [ "int8_t", "int16_t", "int32_t" ]
    additional_simd_template_base_type_mapping_dict: { "int8_t": ["int16_t", "int32_t", "int64_t"], "int16_t": ["int32_t", "int64_t"], "int32_t": ["int64_t"]}
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      return
        _mm256_cvtepi{{ intrin_tp[ctype][1] }}_epi{{ intrin_tp[additional_simd_template_base_type][1] }}(
          _mm_loadu_si128(reinterpret_cast<__m128i const *>(memory))
        );
...
---
primitive_name: "masked_set1"
brief_description: "Partially override a Vector with a single value."
parameters:
   - ctype: "const typename Vec::register_type"
     name: "src"
     description: "Base Vector."
   - ctype: "const typename Vec::imask_type"
     name: "mask"
     description: "Mask of elements to change."
   - ctype: "const typename Vec::base_type"
     name: "value"
     description: "Value to set for elements where the mask bit is 1."
returns:
   ctype: "typename Vec::register_type"
   description: "Base Vector, with the elements specified by mask changed to value."
testing:
   -  requires: ["loadu"]
      includes: ["<cstddef>"]
      implementation: |
        using T = typename Vec::base_type;
        std::size_t element_count = 1024;
        bool allOk = true;
        testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
        auto reference_result_ptr = test_helper.result_ref();
        auto test_result_ptr = test_helper.result_target();
        auto test_data_ptr = test_helper.data_target();
        for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
            T random_value;
            testing::rnd_init(&random_value, 1);
            typename Vec::imask_type random_integral;
            testing::rnd_init(&random_integral, 1);
            auto vec_src = loadu<Vec>( &test_data_ptr[i] );
            auto result = masked_set1<Vec>(vec_src, random_integral, random_value);
            for(std::size_t j = 0; j < Vec::vector_element_count(); j++) {
                reference_result_ptr[j] = (random_integral >> j) & 1 ? random_value : test_data_ptr[i + j];
            }
            allOk &= test_helper.validate_simd_register(result);
        }
        return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw"]
     implementation: "return _mm512_mask_set1_epi{{ intrin_tp[ctype][1] }}(src, mask, value);"
   - target_extension: "avx512"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_mask_set1_epi{{ intrin_tp[ctype][1] }}(src, mask, value);"
   - target_extension: "avx512"
     ctype: ["float"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_castsi512_ps(_mm512_mask_set1_epi32(_mm512_castps_si512(src), mask, *reinterpret_cast<const int32_t*>(&value)));"
   - target_extension: "avx512"
     ctype: ["double"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_castsi512_pd(_mm512_mask_set1_epi64(_mm512_castpd_si512(src), mask, *reinterpret_cast<const int64_t*>(&value)));"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw", "avx512vl"]
     implementation: "return _mm256_mask_set1_epi{{ intrin_tp[ctype][1] }}(src, mask, value);"
   - target_extension: "avx2"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm256_mask_set1_epi{{ intrin_tp[ctype][1] }}(src, mask, value);"
   - target_extension: "avx2"
     ctype: ["float"]
     lscpu_flags: ["avx", "avx512f", "avx512vl"]
     is_native: False
     implementation: "return _mm256_castsi256_ps(_mm256_mask_set1_epi32(_mm256_castps_si256(src), mask, *reinterpret_cast<const int32_t*>(&value)));"
   - target_extension: "avx2"
     ctype: ["double"]
     lscpu_flags: ["avx", "avx512f", "avx512vl"]
     is_native: False
     implementation: "return _mm256_castsi256_pd(_mm256_mask_set1_epi64(_mm256_castpd_si256(src), mask, *reinterpret_cast<const int64_t*>(&value)));"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw", "avx512vl"]
     implementation: "return _mm_mask_set1_epi{{ intrin_tp[ctype][1] }}(src, mask, value);"
   - target_extension: "sse"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm_mask_set1_epi{{ intrin_tp[ctype][1] }}(src, mask, value);"
   - target_extension: "sse"
     ctype: ["float"]
     lscpu_flags: ["sse2", "avx512f", "avx512vl"]
     is_native: False
     implementation: "return _mm_castsi128_ps(_mm_mask_set1_epi32(_mm_castps_si128(src), mask, *reinterpret_cast<const int32_t*>(&value)));"
   - target_extension: "sse"
     ctype: ["double"]
     lscpu_flags: ["avx", "avx512f", "avx512vl"]
     is_native: False
     implementation: "return _mm_castsi128_pd(_mm_mask_set1_epi64(_mm_castpd_si128(src), mask, *reinterpret_cast<const int64_t*>(&value)));"
#NEON
  # TODO
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "return (mask & 1) ? value : src;"
...
---
primitive_name: "maskz_mov"
brief_description: "Copy elements from a vector, where the mask bit it set, otherwise write zero"
parameters:
   - ctype: "const typename Vec::imask_type"
     name: "mask"
     description: "Mask of elements to change."
   - ctype: "const typename Vec::register_type"
     name: "src"
     description: "Base Vector."
returns:
   ctype: "typename Vec::register_type"
   description: "Base Vector, with the elements specified by mask changed to value."
testing:
   -  requires: ["loadu"]
      includes: ["<cstddef>"]
      implementation: |
         using T = typename Vec::base_type;
         std::size_t element_count = 1024;
         bool allOk = true;
         testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
         auto reference_result_ptr = test_helper.result_ref();
         auto test_result_ptr = test_helper.result_target();
         auto test_data_ptr = test_helper.data_target();
         for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
            typename Vec::imask_type random_integral;
            testing::rnd_init(&random_integral, 1);
            auto src = &test_data_ptr[i];
            auto result = maskz_mov<Vec>(random_integral, loadu<Vec>(src));
            for(std::size_t j = 0; j < Vec::vector_element_count(); j++) {
               reference_result_ptr[j] = (random_integral >> j) & 1 ? src[j] : 0;
            }
            allOk &= test_helper.validate_simd_register(result);
         }
         return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw"]
     implementation: "return _mm512_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
   - target_extension: "avx512"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
   - target_extension: "avx512"
     ctype: ["float", double]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_maskz_mov_{{ intrin_tp_full[ctype] }}(mask, src);"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw", "avx512vl"]
     implementation: "return _mm256_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
   - target_extension: "avx2"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm256_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
   - target_extension: "avx2"
     ctype: ["float", double]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm256_maskz_mov_{{ intrin_tp_full[ctype] }}(mask, src);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw", "avx512vl"]
     implementation: "return _mm_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
   - target_extension: "sse"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
   - target_extension: "sse"
     ctype: ["float", double]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm_maskz_mov_{{ intrin_tp_full[ctype] }}(mask, src);"
#NEON
  # TODO
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "return (mask & 1) ? src : 0;"
...
---
primitive_name: "mask_mov"
brief_description: "Merge two vectors while picking the source of each element based on the corresponding mask bit"
parameters:
   - ctype: "const typename Vec::register_type"
     name: "src"
     description: "Vector to pick elements from if mask bit is 0"
   - ctype: "const typename Vec::imask_type"
     name: "mask"
     description: "Mask of elements to change."
   - ctype: "const typename Vec::register_type"
     name: "data"
     description: "Vector to pick elements from if mask bit is 1"

returns:
   ctype: "typename Vec::register_type"
   description: "Base Vector, with the elements specified by mask changed to value."
testing:
   -  requires: ["loadu"]
      includes: ["<cstddef>"]
      implementation: |
        using T = typename Vec::base_type;
        std::size_t element_count = 1024;
        bool allOk = true;
        testing::test_memory_helper_t<Vec> test_helper{element_count * 2, Vec::vector_element_count(), false};
        auto reference_result_ptr = test_helper.result_ref();
        auto test_result_ptr = test_helper.result_target();
        auto test_data_ptr = test_helper.data_target();
        for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
            typename Vec::imask_type random_integral;
            testing::rnd_init(&random_integral, 1);
            auto src = &test_data_ptr[i];
            auto data = &test_data_ptr[element_count + i];
            auto result = mask_mov<Vec>(loadu<Vec>(src), random_integral, loadu<Vec>(data));
            for(std::size_t j = 0; j < Vec::vector_element_count(); j++) {
                reference_result_ptr[j] = (random_integral >> j) & 1 ? data[j] : src[j];
            }
            allOk &= test_helper.validate_simd_register(result);
        }
        return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw"]
     implementation: "return _mm512_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "avx512"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "avx512"
     ctype: ["float", double]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_mask_mov_{{ intrin_tp_full[ctype] }}(src, mask, data);"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw", "avx512vl"]
     implementation: "return _mm256_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "avx2"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm256_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "avx2"
     ctype: ["float", double]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm256_mask_mov_{{ intrin_tp_full[ctype] }}(src, mask, data);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw", "avx512vl"]
     implementation: "return _mm_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "sse"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "sse"
     ctype: ["float", double]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm_mask_mov_{{ intrin_tp_full[ctype] }}(src, mask, data);"
#NEON
  # TODO
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "return (mask & 1) ? data : src;"
...
---
primitive_name: "extract_value"
brief_description: "Extracts value on given index."
additional_non_specialized_template_parameters:
  - ctype: "const int"
    name: "Index"
parameters:
  - ctype: "const typename Vec::register_type"
    name: "data"
returns:
  ctype: "typename Vec::base_type"
  description: "Extracted value."
testing:
  - test_name: "default"
    requires: ["loadu"]
    implementation: |
      using T = typename Vec::base_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 1, false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count; i += Vec::vector_element_count()){
        *reference_result_ptr = reference_data_ptr[i];

        auto vec = loadu<Vec>(&test_data_ptr[i]);
        *test_result_ptr = extract_value<Vec, 0>(vec);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
# INTEL - AVX512
  - target_extension: ["avx512"]
    ctype: ["int8_t", "uint8_t"]
    lscpu_flags: ["avx512f", "avx512bw"]
    implementation: |
      return data[Index];
      /*__m512i idx = _mm512_set1_epi8(Index);
      __m512i result = _mm512_shuffle_epi8(data, idx);
      return ({{ctype}})_mm_extract_epi8(_mm512_castsi512_si128(result), 0);*/
  - target_extension: ["avx512"]
    ctype: ["uint16_t", "int16_t"]
    lscpu_flags: ["avx512f"]
    implementation: |
      return data[Index];
      /*__m128i lane = _mm512_extracti32x4_epi32(data, Index / 8);
      return ({{ctype}})_mm_extract_epi16(lane, Index % 8);*/
  - target_extension: ["avx512"]
    ctype: ["uint32_t", "int32_t", "float"]
    lscpu_flags: ["avx512f"]
    implementation: |
      return data[Index];
      /*__m512i mask = _mm512_set_epi32(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Index);

      {% if ctype == "float" %}
      __m512 permuted = _mm512_permutexvar_ps(mask, data);
      return _mm_cvtss_f32(_mm512_castps512_ps128(permuted));
      {% else %}
      __m512i permuted = _mm512_permutexvar_epi32(mask, data);
      return _mm_cvtsi128_si32(_mm512_castsi512_si128(permuted));
      {% endif %}*/
  - target_extension: ["avx512"]
    ctype: ["uint64_t", "int64_t", "double"]
    lscpu_flags: ["avx512f"]
    implementation: |
      return data[Index];
      /*__m512i mask = _mm512_set_epi64(0, 0, 0, 0, 0, 0, 0, Index);

      {% if ctype == "double" %}
      __m512d permuted = _mm512_permutexvar_pd(mask, data);
      return _mm_cvtsd_f64(_mm512_castpd512_pd128(permuted));
      {% else %}
      __m512i permuted = _mm512_permutexvar_epi64(mask, data);
      return _mm_cvtsi128_si64(_mm512_castsi512_si128(permuted));
      {% endif %}*/
# INTEL - AVX2
  - target_extension: ["avx2"]
    ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
    lscpu_flags: ["avx2"]
    implementation: |
      return data[Index];
      //return _mm256_extract_epi{{intrin_tp[ctype][1]}}(data, Index);
  - target_extension: ["avx2"]
    ctype: ["uint32_t", "uint64_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: |
      return data[Index];
      //return _mm256_extract_epi{{intrin_tp[ctype][1]}}(data, Index);
  - target_extension: ["avx2"]
    ctype: ["float"]
    lscpu_flags: ["avx"]
    implementation: |
      return data[Index];
      /*__m256 temp = _mm256_permute_ps(data, _MM_SHUFFLE(Index, Index, Index, Index));
      return _mm256_cvtss_f32(temp);*/
  - target_extension: ["avx2"]
    ctype: ["double"]
    lscpu_flags: ["avx2", "avx"]
    implementation: |
      return data[Index];
      /*__m256d temp = _mm256_permute4x64_pd(data, _MM_SHUFFLE(Index, Index, Index, Index));
      return _mm256_cvtsd_f64(temp);*/
# INTEL - SSE
  - target_extension: ["sse"]
    ctype: ["uint8_t", "uint32_t", "uint64_t", "int8_t", "int32_t", "int64_t"]
    lscpu_flags: ["sse4_1"]
    implementation: |
      return data[Index];
      //return _mm_extract_epi{{intrin_tp[ctype][1]}}(data, Index);
  - target_extension: ["sse"]
    ctype: ["uint16_t", "int16_t"]
    lscpu_flags: ["sse2"]
    implementation: |
      return data[Index];
      //return _mm_extract_epi{{intrin_tp[ctype][1]}}(data, Index);
  - target_extension: ["sse"]
    ctype: ["float"]
    lscpu_flags: ["sse2"]
    implementation: |
      return data[Index];
      /*__m128 temp = _mm_shuffle_ps(data, data, _MM_SHUFFLE(Index, Index, Index, Index));
      return _mm_cvtss_f32(temp);*/
  - target_extension: ["sse"]
    ctype: ["double"]
    lscpu_flags: ["sse2"]
    implementation: |
      return data[Index];
      /*__m128d temp = _mm_shuffle_pd(data, data, Index);
      return _mm_cvtsd_f64(temp);*/
# SCALAR
  - target_extension: ["scalar"]
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: return data;
...
