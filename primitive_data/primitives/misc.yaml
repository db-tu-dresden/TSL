---
name: "misc"
description: "Miscellaneous primitives."
...
---
primitive_name: "conflict"
brief_description: "Checks whether all elements are unique in a register."
parameters:
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Data vector."
    declaration_attributes: "[[maybe_unused]]"
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing result of the uniqueness check."
testing:
  - test_name: "default"
    requires: ["storeu", "loadu"]
    implementation: |
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i += Vec::vector_element_count()){
        std::size_t idx = 0;
        typename Vec::base_type data[Vec::vector_element_count()];
        for (std::size_t k = i; k < i + Vec::vector_element_count(); k++) {
          data[idx] = 0;
          for (std::size_t j = i; j < k; j++) {
            if(reference_data_ptr[j] == reference_data_ptr[k]){
              data[idx] |= (1 << (j - i));
            }
          }
          idx ++;
        }
        auto vec_ref = loadu<Vec>(data);
        storeu<Vec>(reference_result_ptr, vec_ref);

        auto vec = loadu<Vec>(&test_data_ptr[i]);
        auto vec_result = conflict<Vec>(vec);

        storeu<Vec>(test_result_ptr, vec_result);
        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint32_t", "uint64_t","int32_t", "int64_t"]
    lscpu_flags: ["avx512f", "avx512cd"]
    implementation: "return _mm512_conflict_epi{{ intrin_tp[ctype][1] }}(data);"
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    is_native: False
    implementation: |
       alignas(Vec::vector_alignment())
         std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
       alignas(Vec::vector_alignment())
         std::array<typename Vec::base_type, Vec::vector_element_count()> conflicts{};
       _mm512_store_si512(reinterpret_cast<void*>(tmp.data()), data);
       _mm512_store_si512(reinterpret_cast<void*>(conflicts.data()), _mm512_setzero_si512());
       for(unsigned ref = 1; ref < Vec::vector_element_count(); ++ref) {
         for(unsigned cur = 0; cur < ref; ++cur) {
           if(tmp[ref] == tmp[cur]) {
             conflicts[ref] |= (1<<cur);
           }
         }
       }
       return _mm512_load_si512(reinterpret_cast<void const*>(conflicts.data()));
  #Intel - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      alignas(Vec::vector_alignment())
        std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      alignas(Vec::vector_alignment())
        std::array<typename Vec::base_type, Vec::vector_element_count()> conflicts{};
      _mm256_store_si256(reinterpret_cast<__m256i*>(tmp.data()), data);
      _mm256_store_si256(reinterpret_cast<__m256i*>(conflicts.data()), _mm256_setzero_si256());
      for(unsigned ref = 1; ref < Vec::vector_element_count(); ++ref) {
        for(unsigned cur = 0; cur < ref; ++cur) {
          if(tmp[ref] == tmp[cur]) {
            conflicts[ref] |= (1<<cur);
          }
        }
      }
      return _mm256_load_si256(reinterpret_cast<__m256i const*>(conflicts.data()));
  #Intel - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["sse2"]
    is_native: False
    implementation: |
      alignas(Vec::vector_alignment())
        std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      alignas(Vec::vector_alignment())
        std::array<typename Vec::base_type, Vec::vector_element_count()> conflicts{};
      _mm_store_si128(reinterpret_cast<__m128i*>(tmp.data()), data);
      _mm_store_si128(reinterpret_cast<__m128i*>(conflicts.data()), _mm_setzero_si128());
      for(unsigned ref = 1; ref < Vec::vector_element_count(); ++ref) {
        for(unsigned cur = 0; cur < ref; ++cur) {
          if(tmp[ref] == tmp[cur]) {
            conflicts[ref] |= (1<<cur);
          }
        }
      }
      return _mm_load_si128(reinterpret_cast<__m128i const*>(conflicts.data()));
  #ARM - NEON
  - target_extension: "neon"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: [ 'neon' ]
    is_native: False
    implementation: |
      alignas(Vec::vector_alignment())
        std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      alignas(Vec::vector_alignment())
        std::array<typename Vec::base_type, Vec::vector_element_count()> conflicts{};
      vst1q_{{ intrin_tp_full[ctype] }}(tmp.data(), data);
      for(unsigned idx = 0; idx < Vec::vector_element_count(); ++idx) {
        conflicts[idx] = 0;
      }
      for(unsigned ref = 1; ref < Vec::vector_element_count(); ++ref) {
        for(unsigned cur = 0; cur < ref; ++cur) {
          if(tmp[ref] == tmp[cur]) {
            conflicts[ref] |= (1<<cur);
          }
        }
      }
      return vld1q_{{ intrin_tp_full[ctype] }}(conflicts.data());
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: []
    implementation: "return 0;"
  #FPGA
  - target_extension: ["oneAPIfpga"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["oneAPIfpgaDev"]
    includes: ["<climits>"]
    vector_length_agnostic: True
    implementation: |
      static_assert(Vec::vector_element_count() <= CHAR_BIT*sizeof(typename Vec::base_type), "Vector element count must be less or equal to the number of bits in the base type.");
      typename Vec::register_type result{};
      tsl::oneAPIfpgaFun::details::conflictReduce<Vec>(result, data, std::make_index_sequence<Vec::vector_element_count()-1>{});
      result[0] = 0;
      return result;
  - target_extension: ["oneAPIfpgaRTL"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["oneAPIfpgaDev"]
    includes: ["<climits>"]
    vector_length_agnostic: True
    specialization_comment: "This is just for testing reasons (CIDR crc)"
    implementation: |
      static_assert(Vec::vector_element_count() <= CHAR_BIT*sizeof(typename Vec::base_type), "Vector element count must be less or equal to the number of bits in the base type.");
      typename Vec::register_type result{};
      #pragma unroll Vec::vector_element_count()
      for (auto iteration_start = 1; iteration_start < Vec::vector_element_count(); ++iteration_start) {
        #pragma unroll Vec::vector_element_count()
        for (size_t i = 0; i < Vec::vector_element_count() - iteration_start; ++i) {
          result[iteration_start+i] |= (data[iteration_start+i] == data[i]) ? 1<<i : 0;
        }
      }
...
---
primitive_name: "conflict_free"
functor_name: "imask_conflict_free"
brief_description: "Checks whether all elements are unique in a register and returns a mask indicating which elements don't have preceeding conflicts."
parameters:
  - ctype: "const typename Vec::imask_type"
    name: "mask"
    description: "Mask indicating which lanes should be considered for conflict detection. Be aware, that non-valid lanes can still conflict with others."
    declaration_attributes: "[[maybe_unused]]"
  - ctype: "const typename Vec::register_type"
    name: "data"
    description: "Data vector."
    declaration_attributes: "[[maybe_unused]]"
returns:
  ctype: "typename Vec::imask_type"
  description: "integral mask containing result of the uniqueness check."
testing:
  - test_name: "default"
    requires: ["loadu", "integral_all_true"]
    implementation: |
      using mask_t = typename Vec::imask_type;
      std::size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, 1, false};
      bool allOk = true;
      auto reference_data_ptr = test_helper.data_ref();
      auto reference_result_ptr = test_helper.result_ref();
      auto test_data_ptr = test_helper.data_target();
      auto test_result_ptr = test_helper.result_target();
      for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i += Vec::vector_element_count()){
        mask_t bitmask = 0;
        for (std::size_t k = i; k < i + Vec::vector_element_count(); k++) {
          bool isUnique = true;
          for (std::size_t j = i; j < k; j++) {
            if(reference_data_ptr[j] == reference_data_ptr[k]){
              isUnique = false;
              break;
            }
          }
          if(isUnique) {
            bitmask |= (static_cast<mask_t>(1) << (k - i));
          }
        }
        *reference_result_ptr = bitmask;
        auto vec = loadu<Vec>(&test_data_ptr[i]);
        *test_result_ptr = conflict_free<Vec>(integral_all_true<Vec>(), vec);

        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint32_t", "uint64_t","int32_t", "int64_t"]
    lscpu_flags: ["avx512f", "avx512cd"]
    implementation: |
      auto const conflict_reg = _mm512_maskz_conflict_epi{{ intrin_tp[ctype][1] }}(mask, data);
      auto const mask_reg = _mm512_set1_epi{{ intrin_tp[ctype][1] }}(mask);
      auto const cleaned_conflict_reg = _mm512_and_si512(conflict_reg, mask_reg);
      return _mm512_mask_cmpeq_epi{{ intrin_tp[ctype][1] }}_mask(mask, cleaned_conflict_reg, _mm512_setzero_si512());
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    is_native: False
    implementation: |
      typename Vec::imask_type result = 0;
      alignas(Vec::vector_alignment())
        std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      _mm512_store_si512(reinterpret_cast<void*>(tmp.data()), data);
      typename Vec::imask_type pos = 2;
      for(unsigned ref = 1; ref < Vec::vector_element_count(); ++ref) {
        if(((mask>>ref)&0b1)==1) {
          for(unsigned cur = 0; cur < ref; ++cur) {
            if(((mask>>cur)&0b1)==1) {
              if(tmp[ref] == tmp[cur]) {
                result |= pos;
                break;
              }
            }
          }
        }
        pos <<= 1;
      }
      return (~result & mask);
  #Intel - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    specialization_comment: "@todo This can be done better using some shuffle instructions cleverly."
    implementation: |
      typename Vec::imask_type result = 0;
      alignas(Vec::vector_alignment())
        std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      _mm256_store_si256(reinterpret_cast<__m256i*>(tmp.data()), data);
      typename Vec::imask_type pos = 2;
      for(unsigned ref = 1; ref < Vec::vector_element_count(); ++ref) {
        if(((mask>>ref)&0b1)==1) {
          for(unsigned cur = 0; cur < ref; ++cur) {
            if(((mask>>cur)&0b1)==1) {
              if(tmp[ref] == tmp[cur]) {
                result |= pos;
                break;
              }
            }
          }
        }
        pos <<= 1;
      }
      return (~result & mask);
  #Intel - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: ["sse2"]
    is_native: False
    implementation: |
      typename Vec::imask_type result = 0;
      alignas(Vec::vector_alignment())
        std::array<typename Vec::base_type, Vec::vector_element_count()> tmp{};
      _mm_store_si128(reinterpret_cast<__m128i*>(tmp.data()), data);
      typename Vec::imask_type pos = 2;
      for(unsigned ref = 1; ref < Vec::vector_element_count(); ++ref) {
        if(((mask>>ref)&0b1)==1) {
          for(unsigned cur = 0; cur < ref; ++cur) {
            if(((mask>>cur)&0b1)==1) {
              if(tmp[ref] == tmp[cur]) {
                result |= pos;
                break;
              }
            }
          }
        }
        pos <<= 1;
      }
      return (~result & mask);
  #SCALAR
  - target_extension: "scalar"
    ctype: [ "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t"]
    lscpu_flags: []
    implementation: "return 1;"
...
---
primitive_name: "blend"
brief_description: "Blends two registers using provided bitmask."
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "control"
    description: "If control[i] == 0, the corresponding value from left register is used, from right otherwise."
  - ctype: "const typename Vec::register_type"
    name: "left"
    description: "Left data."
  - ctype: "const typename Vec::register_type"
    name: "right"
    description: "Right data."
returns:
  ctype: "typename Vec::register_type"
  description: "Vector containing blended data."
testing:
  - test_name: "default"
    requires: ["loadu", "storeu", "to_mask", "to_array"]
    implementation: |
      using base_t = typename Vec::base_type;
      using reg_t = typename Vec::register_type;
      auto vec_count = Vec::vector_element_count();
      size_t element_count = 1024;
      testing::test_memory_helper_t<Vec> test_helper{element_count, vec_count, false};
      auto ref_result_ptr = test_helper.result_ref();
      auto ref_data_ptr = test_helper.data_ref();
      auto test_result_ptr = test_helper.result_target();
      auto test_data_ptr = test_helper.data_target();
      bool allOk = true;

      for(size_t i = 0; i < element_count; i += 2*vec_count){
        typename Vec::imask_type mask;
        testing::rnd_init(&mask, 1);
        base_t arr[vec_count];
        for(size_t j = 0; j < vec_count; j++){
          (((mask >> j) & 1) == 0) ? arr[j] = ref_data_ptr[j+i] : arr[j] = ref_data_ptr[i+j+vec_count];
        }
        auto ref_result = loadu<Vec>(arr);

        auto vec_a = loadu<Vec>(&test_data_ptr[i]);
        auto vec_b = loadu<Vec>(&test_data_ptr[i+vec_count]);
        auto result = blend<Vec>(to_mask<Vec>(mask), vec_a, vec_b);

        storeu<Vec>(test_result_ptr, result);
        storeu<Vec>(ref_result_ptr, ref_result);

        test_helper.synchronize();
        allOk &= test_helper.validate();
      }
      return allOk;
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t"]
    lscpu_flags: ['avx512f', 'avx512bw']
    implementation: "return _mm512_mask_blend_epi{{ intrin_tp[ctype][1] }}(control, left, right);"
  - target_extension: "avx512"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_mask_blend_epi{{ intrin_tp[ctype][1] }}(control, left, right);"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_mask_blend_{{ intrin_tp_full[ctype] }}(control, left, right);"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx2']
    implementation: "return _mm256_or_si256(_mm256_andnot_si256(control, left), _mm256_and_si256(control,right));"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ['avx2']
    #implementation: "return _mm256_or_{{ intrin_tp_full[ctype] }}(_mm256_andnot_{{ intrin_tp_full[ctype] }}(_mm256_castsi256_{{ intrin_tp_full[ctype] }}(control), left), _mm256_and_{{ intrin_tp_full[ctype] }}(_mm256_castsi256_{{
    #intrin_tp_full[ctype] }}(control),right));"
    implementation: "return _mm256_or_{{ intrin_tp_full[ctype] }}(_mm256_andnot_{{ intrin_tp_full[ctype] }}(control, left), _mm256_and_{{ intrin_tp_full[ctype] }}(control,right));"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t" , "int8_t","uint16_t", "int16_t", "int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['sse2']
    implementation: "return _mm_or_si128(_mm_andnot_si128(control, left), _mm_and_si128(control,right));"
  - target_extension: "sse"
    ctype: ["float", "double"]
    lscpu_flags: ['avx2']
    #implementation: "return _mm_or_{{ intrin_tp_full[ctype] }}(_mm_andnot_{{ intrin_tp_full[ctype] }}(_mm_castsi128_{{ intrin_tp_full[ctype] }}(control), left), _mm_and_{{ intrin_tp_full[ctype] }}(_mm_castsi128_{{ intrin_tp_full[ctype] }}
    #(control),right));"
    implementation: "return _mm_or_{{ intrin_tp_full[ctype] }}(_mm_andnot_{{ intrin_tp_full[ctype] }}(control, left), _mm_and_{{ intrin_tp_full[ctype] }}(control,right));"
  # SCALAR
  - target_extension: ["scalar"]
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return (static_cast<bool>(control))? right : left;"
...
---
primitive_name: "blend_add"
brief_description: "Blends or add two registers using provided bitmask"
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "control"
  - ctype: "const typename Vec::register_type"
    name: "left"
    description: "Left data."
  - ctype: "const typename Vec::register_type"
    name: "right"
    description: "Right data."
  - ctype: "const typename Vec::register_type"
    name: "adder"
    description: "Adder data."
returns:
  ctype: "typename Vec::register_type"
  descriptions: "result[i] = (control[i]==1)? left[i]  : right[i] + adder[i]"
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    is_native: False
    implementation: |
      auto const right_added_part = _mm512_add_epi{{ intrin_tp[ctype][1] }}(right, adder);
      return _mm512_mask_blend_epi{{ intrin_tp[ctype][1] }}(control, right_added_part, left);
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t"]
    lscpu_flags: ["avx512f", "avx512bw"]
    is_native: False
    implementation: |
      auto const right_added_part = _mm512_add_epi{{ intrin_tp[ctype][1] }}(right, adder);
      return _mm512_mask_blend_epi{{ intrin_tp[ctype][1] }}(control, right_added_part, left);
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx2"]
    is_native: False
    implementation: |
      auto const left_part = _mm256_and_si256(control, left);
      auto const right_added_part = _mm256_andnot_si256(control, _mm256_add_epi{{ intrin_tp[ctype][1] }}(right, adder));
      return _mm256_or_si256(left_part, right_added_part);
...
---
primitive_name: "undefined"
brief_description: "Returns a vector register with undefined data inside."
returns:
  ctype: "typename Vec::register_type"
  description: "SIMD reigster"
definitions:
  #INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_undefined_epi32();"
  - target_extension: "avx512"
    ctype: ["float", "double"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_undefined_{{ intrin_tp_full[ctype] }}();"
  #INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_undefined_si256();"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_undefined_{{ intrin_tp_full[ctype] }}();"
  #INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "int8_t", "uint16_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_undefined_si128();"
  - target_extension: "sse"
    ctype: ["float", "double"]
    lscpu_flags: ["sse", "sse2"]
    implementation: "return _mm_undefined_{{ intrin_tp_full[ctype] }}();"
...
---
primitive_name: "maskz_mov"
brief_description: "Copy elements from a vector, where the mask bit it set, otherwise write zero"
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "mask"
    description: "Mask of elements to change."
  - ctype: "const typename Vec::register_type"
    name: "src"
    description: "Base Vector."
returns:
  ctype: "typename Vec::register_type"
  description: "Base Vector, with the elements specified by mask changed to value."
testing:
  - requires: ["loadu"]
    includes: ["<cstddef>"]
    implementation: |
        using T = typename Vec::base_type;
        std::size_t element_count = 1024;
        bool allOk = true;
        testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
        auto reference_result_ptr = test_helper.result_ref();
        auto test_result_ptr = test_helper.result_target();
        auto test_data_ptr = test_helper.data_target();
        for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          typename Vec::imask_type random_integral;
          testing::rnd_init(&random_integral, 1);
          auto src = &test_data_ptr[i];
          auto result = maskz_mov<Vec>(random_integral, loadu<Vec>(src));
          for(std::size_t j = 0; j < Vec::vector_element_count(); j++) {
              reference_result_ptr[j] = (random_integral >> j) & 1 ? src[j] : 0;
          }
          allOk &= test_helper.validate_simd_register(result);
        }
        return allOk;
definitions:
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_and_si256(src, mask);"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_and_{{ intrin_tp_full[ctype] }}(src, mask);"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_and_si128(mask, src);"
  - target_extension: "sse"
    ctype: ["float", double]
    lscpu_flags: ["sse", "sse2"]
    implementation: "return _mm_and_{{ intrin_tp_full[ctype] }}(mask, src);"
...
---
primitive_name: "maskz_mov"
functor_name: "imaskz_mov"
brief_description: "Copy elements from a vector, where the mask bit it set, otherwise write zero"
parameters:
  - ctype: "const typename Vec::imask_type"
    name: "mask"
    description: "Mask of elements to change."
  - ctype: "const typename Vec::register_type"
    name: "src"
    description: "Base Vector."
returns:
  ctype: "typename Vec::register_type"
  description: "Base Vector, with the elements specified by mask changed to value."
testing:
  - requires: ["loadu"]
    includes: ["<cstddef>"]
    implementation: |
        using T = typename Vec::base_type;
        std::size_t element_count = 1024;
        bool allOk = true;
        testing::test_memory_helper_t<Vec> test_helper{element_count, Vec::vector_element_count(), false};
        auto reference_result_ptr = test_helper.result_ref();
        auto test_result_ptr = test_helper.result_target();
        auto test_data_ptr = test_helper.data_target();
        for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
          typename Vec::imask_type random_integral;
          testing::rnd_init(&random_integral, 1);
          auto src = &test_data_ptr[i];
          auto result = maskz_mov<Vec>(random_integral, loadu<Vec>(src));
          for(std::size_t j = 0; j < Vec::vector_element_count(); j++) {
              reference_result_ptr[j] = (random_integral >> j) & 1 ? src[j] : 0;
          }

          bool ok = test_helper.validate_simd_register(result);
          if (!ok) {
            std::cerr << "Error at index " << i << std::endl;
          }
          allOk &= ok;
        }
        return allOk;
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
    lscpu_flags: ["avx512bw"]
    implementation: "return _mm512_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
  - target_extension: "avx512"
    ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
  - target_extension: "avx512"
    ctype: ["float", double]
    lscpu_flags: ["avx512f"]
    implementation: "return _mm512_maskz_mov_{{ intrin_tp_full[ctype] }}(mask, src);"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
    lscpu_flags: ["avx512bw", "avx512vl"]
    implementation: "return _mm256_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
  - target_extension: "avx2"
    ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
    lscpu_flags: ["avx512f", "avx512vl"]
    implementation: "return _mm256_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
  - target_extension: "avx2"
    ctype: ["float", double]
    lscpu_flags: ["avx512f", "avx512vl"]
    implementation: "return _mm256_maskz_mov_{{ intrin_tp_full[ctype] }}(mask, src);"
  - target_extension: "avx2"
    ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["avx2"]
    implementation: "return _mm256_and_si256(src, tsl::to_mask<Vec>(mask));"
  - target_extension: "avx2"
    ctype: ["float", "double"]
    lscpu_flags: ["avx"]
    implementation: "return _mm256_and_{{ intrin_tp_full[ctype] }}(src, tsl::to_mask<Vec>(mask));"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
    lscpu_flags: ["avx512bw", "avx512vl"]
    implementation: "return _mm_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
  - target_extension: "sse"
    ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
    lscpu_flags: ["avx512f", "avx512vl"]
    implementation: "return _mm_maskz_mov_epi{{ intrin_tp[ctype][1] }}(mask, src);"
  - target_extension: "sse"
    ctype: ["float", double]
    lscpu_flags: ["avx512f", "avx512vl"]
    implementation: "return _mm_maskz_mov_{{ intrin_tp_full[ctype] }}(mask, src);"
  - target_extension: "sse"
    ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t", "uint32_t", "int32_t", "uint64_t", "int64_t"]
    lscpu_flags: ["sse2"]
    implementation: "return _mm_and_si128(tsl::to_mask<Vec>(mask), src);"
  - target_extension: "sse"
    ctype: ["float", double]
    lscpu_flags: ["sse", "sse2"]
    implementation: "return _mm_and_{{ intrin_tp_full[ctype] }}(tsl::to_mask<Vec>(mask), src);"
#NEON
  # TODO
#SCALAR
  - target_extension: "scalar"
    ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return (mask & 1) ? src : 0;"
...
---
primitive_name: "mask_mov"
brief_description: "Merge two vectors while picking the source of each element based on the corresponding mask bit"
parameters:
   - ctype: "const typename Vec::register_type"
     name: "src"
     description: "Vector to pick elements from if mask bit is 0"
   - ctype: "const typename Vec::imask_type"
     name: "mask"
     description: "Mask of elements to change."
   - ctype: "const typename Vec::register_type"
     name: "data"
     description: "Vector to pick elements from if mask bit is 1"
returns:
   ctype: "typename Vec::register_type"
   description: "Base Vector, with the elements specified by mask changed to value."
testing:
   -  requires: ["loadu"]
      includes: ["<cstddef>"]
      implementation: |
        using T = typename Vec::base_type;
        std::size_t element_count = 1024;
        bool allOk = true;
        testing::test_memory_helper_t<Vec> test_helper{element_count * 2, Vec::vector_element_count(), false};
        auto reference_result_ptr = test_helper.result_ref();
        auto test_result_ptr = test_helper.result_target();
        auto test_data_ptr = test_helper.data_target();
        for(std::size_t i = 0; i < element_count - Vec::vector_element_count(); i+=Vec::vector_element_count()) {
            typename Vec::imask_type random_integral;
            testing::rnd_init(&random_integral, 1);
            auto src = &test_data_ptr[i];
            auto data = &test_data_ptr[element_count + i];
            auto result = mask_mov<Vec>(loadu<Vec>(src), random_integral, loadu<Vec>(data));
            for(std::size_t j = 0; j < Vec::vector_element_count(); j++) {
                reference_result_ptr[j] = (random_integral >> j) & 1 ? data[j] : src[j];
            }
            allOk &= test_helper.validate_simd_register(result);
        }
        return allOk;
definitions:
#INTEL - AVX512
   - target_extension: "avx512"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw"]
     implementation: "return _mm512_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "avx512"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "avx512"
     ctype: ["float", double]
     lscpu_flags: ["avx512f"]
     implementation: "return _mm512_mask_mov_{{ intrin_tp_full[ctype] }}(src, mask, data);"
#INTEL - AVX2
   - target_extension: "avx2"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw", "avx512vl"]
     implementation: "return _mm256_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "avx2"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm256_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "avx2"
     ctype: ["float", double]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm256_mask_mov_{{ intrin_tp_full[ctype] }}(src, mask, data);"
#INTEL - SSE
   - target_extension: "sse"
     ctype: ["uint8_t", "uint16_t", "int8_t", "int16_t"]
     lscpu_flags: ["avx512bw", "avx512vl"]
     implementation: "return _mm_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "sse"
     ctype: ["int32_t", "int64_t", "uint32_t", "uint64_t"]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm_mask_mov_epi{{ intrin_tp[ctype][1] }}(src, mask, data);"
   - target_extension: "sse"
     ctype: ["float", double]
     lscpu_flags: ["avx512f", "avx512vl"]
     implementation: "return _mm_mask_mov_{{ intrin_tp_full[ctype] }}(src, mask, data);"
#NEON
  # TODO
#SCALAR
   - target_extension: "scalar"
     ctype: ["uint8_t", "uint16_t", "uint32_t", "uint64_t", "int8_t", "int16_t", "int32_t", "int64_t", "float", "double"]
     lscpu_flags: []
     implementation: "return (mask & 1) ? data : src;"
...
---
primitive_name: "to_integral"
brief_description: "Forms an integral value from the most significant bits of every lane in a vector mask register."
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "vec_mask"
    description: "Vector mask register containing mask style data."
returns:
  ctype: "typename Vec::imask_type"
  description: "Integral value representing of the vector mask register."
testing: #optional
  - test_name: "mask_match_zero_to_vec_count"
    requires: []
    includes: ["<cstddef>", "<array>"]
    implementation: |
      if constexpr (std::is_same_v<bool, typename Vec::mask_type>) {
        std::cerr << "implement me" << std::endl;
        return true;
      } else if constexpr (std::is_same_v<typename Vec::mask_type, typename Vec::imask_type>) {
        //we don't need to do anything here since it is a NOP.
        return true;
      } else {
        using T = typename Vec::base_type;
        typename Vec::imask_type expected_result = 0;
        auto transformed = to_integral<Vec>(to_mask<Vec>(expected_result));
        return transformed == expected_result;
      }
  - test_name: "mask_match_alternate"
    includes: ["<cstddef>", "<array>", "<iostream>", "<bitset>"]
    implementation: |
      if constexpr (std::is_same_v<bool, typename Vec::mask_type>) {
        std::cerr << "implement me" << std::endl;
        return true;
      } else if constexpr (std::is_same_v<typename Vec::mask_type, typename Vec::imask_type>) {
        //we don't need to do anything here since it is a NOP.
        return true;
      } else {
        using T = typename Vec::base_type;
        typename Vec::imask_type expected_result = 0;
        for (size_t i = 0; i < Vec::vector_element_count(); ++i) {
          if ((i % 2) == 0) {
            expected_result |= (1 << i);
          }
        }
        auto transformed = to_integral<Vec>(to_mask<Vec>(expected_result));
        bool ok = (transformed == expected_result);
        if (!ok) {
          std::cerr << "expected: " << std::bitset<sizeof(typename Vec::imask_type) * 8>(expected_result) << std::endl;
          std::cerr << "transformed: " << std::bitset<sizeof(typename Vec::imask_type) * 8>(transformed) << std::endl;
        }
        return ok;
      }
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['avx512f']
    implementation: "return vec_mask; //mask is integral already."
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t"]
    lscpu_flags: ['avx2']
    implementation: "return _mm256_movemask_epi8(vec_mask);"
  - target_extension: "avx2"
    ctype: ["int16_t", "uint16_t"]
    lscpu_flags: ['avx','avx2', 'bmi2']
    is_native: False
    implementation: "return _pext_u32(_mm256_movemask_epi8(vec_mask), 0x55555555);"
  - target_extension: "avx2"
    ctype: ["int16_t", "uint16_t"]
    lscpu_flags: ['avx', 'avx2']
    is_native: False
    implementation: |
      auto const packed = _mm256_packs_epi16(vec_mask, _mm256_setzero_si256());
      auto const shuffled = _mm256_permute4x64_epi64(packed, 8);
      return static_cast<typename Vec::imask_type>(_mm256_movemask_epi8(shuffled));
#   - target_extension: "avx2"
#     ctype: ["int16_t", "uint16_t"]
#     lscpu_flags: ['avx', 'avx2']
#     is_native: False
#     implementation: |
#       __m256i shift = _mm256_set_epi32(16,16,16,16,0,0,0,0);
#                     __m256i vec_and = _mm256_set1_epi32(0xffff);
#                     __m256i res_vec_p1 = _mm256_and_si256(
#                        _mm256_srlv_epi32(
#                           _mm256_permute4x64_epi64(vec_mask, 0b01000100),
#                           shift
#                        ),
#                        vec_and
#                     );
#                     __m256i res_vec_p2 = _mm256_and_si256(
#                        _mm256_srlv_epi32(
#                          _mm256_permute4x64_epi64(vec_mask, 0b11101110),
#                          shift
#                        ),
#                        vec_and
#                     );
#                     uint16_t a = _mm256_movemask_ps(
#                        _mm256_castsi256_ps(
#                           _mm256_slli_epi32(
#                              _mm256_castps_si256(
#                                 _mm256_permute_ps(
#                                    _mm256_castsi256_ps(
#                                       _mm256_permute4x64_epi64(res_vec_p1, 216)
#                                    ),
#                                    216
#                                 )
#                              ),
#                              16
#                           )
#                        )
#                     );
#                     uint16_t b = _mm256_movemask_ps(
#                        _mm256_castsi256_ps(
#                           _mm256_slli_epi32(
#                              _mm256_castps_si256(
#                                 _mm256_permute_ps(
#                                    _mm256_castsi256_ps(
#                                       _mm256_permute4x64_epi64(res_vec_p2, 216)
#                                    ),
#                                    216
#                                 )
#                              ),
#                              16
#                           )
#                        )
#                     );
#                     return (b << 8) | a;
  - target_extension: "avx2"
    ctype: ["float"]
    lscpu_flags: ['avx']
    implementation: "return _mm256_movemask_ps(vec_mask);"
  - target_extension: "avx2"
    ctype: ["int32_t", "uint32_t"]
    lscpu_flags: ['avx']
    implementation: "return _mm256_movemask_ps(_mm256_castsi256_ps(vec_mask));"
  - target_extension: "avx2"
    ctype: ["int64_t", "uint64_t"]
    lscpu_flags: ['avx']
    implementation: "return _mm256_movemask_pd(_mm256_castsi256_pd(vec_mask));"
  - target_extension: "avx2"
    ctype: ["double"]
    lscpu_flags: ['avx']
    implementation: "return _mm256_movemask_pd(vec_mask);"
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t"]
    lscpu_flags: ['sse2']
    implementation: "return _mm_movemask_epi8(vec_mask);"
  - target_extension: "sse"
    ctype: ["int16_t", "uint16_t"]
    lscpu_flags: ['sse', 'sse2', 'bmi2']
    is_native: False
    implementation: "return _pext_u32(_mm_movemask_epi8(vec_mask), 0x5555);"
  - target_extension: "sse"
    ctype: ["int16_t", "uint16_t"]
    lscpu_flags: ['sse', 'sse2']
    is_native: False
    implementation: |
      return static_cast<typename Vec::imask_type>(_mm_movemask_epi8(_mm_packs_epi16(vec_mask, _mm_setzero_si128())));
#   - target_extension: "sse"
#     ctype: ["int16_t", "uint16_t"]
#     lscpu_flags: ['sse', 'sse2']
#     is_native: False
#     implementation: |
#       vec_mask = _mm_shuffle_epi32(vec_mask, 0b11011000);
#                     vec_mask = _mm_shufflehi_epi16(vec_mask, 0b11011000);
#                     vec_mask = _mm_shufflelo_epi16(vec_mask, 0b11011000);
#                     uint16_t a = _mm_movemask_ps(
#                        _mm_castsi128_ps(
#                           _mm_slli_epi32(vec_mask, 16)
#                        )
#                     );
#                     uint16_t b = _mm_movemask_ps(
#                        _mm_castsi128_ps(vec_mask)
#                     );
#                     return (b<<4) | a;
  - target_extension: "sse"
    ctype: ["float"]
    lscpu_flags: ['sse']
    implementation: "return _mm_movemask_ps(vec_mask);"
  - target_extension: "sse"
    ctype: ["int32_t", "uint32_t"]
    lscpu_flags: ['sse', 'sse2']
    implementation: "return _mm_movemask_ps(_mm_castsi128_ps(vec_mask));"
  - target_extension: "sse"
    ctype: ["int64_t", "uint64_t"]
    lscpu_flags: ['sse2']
    implementation: "return _mm_movemask_pd(_mm_castsi128_pd(vec_mask));"
  - target_extension: "sse"
    ctype: ["double"]
    lscpu_flags: ['sse2']
    implementation: "return _mm_movemask_pd(vec_mask);"
#ARM - NEON
#todo: ARM IMPLEMENTATION for other bitwidths
  - target_extension: "neon"
    ctype: ["uint64_t", "int64_t", "double"]
    lscpu_flags: [ 'neon' ]
    is_native: False
    implementation: "return ( ( vec_mask[ 1 ] >> 62 ) & 0b10 ) | ( vec_mask[ 0 ] >> 63 );"
  - target_extension: "neon"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "float"]
    lscpu_flags: ["neon"]
    is_native: False
    implementation: |
      auto mask_values_array = tsl::to_array<typename Vec::transform_extension<typename Vec::offset_base_type>>(vec_mask);
      typename Vec::imask_type mask_integral = 0;
      for (size_t i = 0; i < Vec::vector_element_count(); ++i) {
        mask_integral |= (mask_values_array[i] & 0b1) << i;
      }
      return mask_integral;
#SCALAR
  - target_extension: "scalar"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: []
    implementation: "return (vec_mask)? 1 : 0;"
...
#---
#primitive_name: "get_msb"
#brief_description: "Retrieves the most significant bit of every element in a vector register and sets the corresponding bit in a base type."
#parameters:
#   - ctype: "const typename Vec::register_type"
#     name: "vec"
#     description: "Vector mask register containing mask style data."
#returns:
#   ctype: "typename Vec::base_type"
#   description: "Integral value representing the vector mask register."
#definitions:
##INTEL - AVX512
#   - target_extension: "avx512"
#     ctype: "int64_t"
#     lscpu_flags: ['avx512f', 'avx512dq']
#     implementation: "return _mm512_movepi64_mask( vec );"
##INTEL - AVX2
#   - target_extension: "avx2"
#     ctype: "int64_t"
#     lscpu_flags: [ 'avx' ]
#     implementation: "return _mm256_movemask_pd( _mm256_castsi256_pd( vec ) );"
##INTEL - SSE
#   - target_extension: "sse"
#     ctype: "int64_t"
#     lscpu_flags: [ 'sse2' ]
#     implementation: "return _mm_movemask_pd( _mm_castsi128_pd( vec ) );"
##ARM - NEON
#   - target_extension: "neon"
#     ctype: "int64_t"
#     lscpu_flags: [ 'neon' ]
#     is_native: False
#     implementation: "return ( ( vec[ 1 ] >> 62 ) & 0b10 ) | ( vec[ 0 ] >> 63 );"
#...
---
primitive_name: "to_vector"
brief_description: "Forms an vector register from an integral where all bits are set in a lane if the corresponding mask bit is set to 1."
parameters:
  - ctype: "const typename Vec::mask_type"
    name: "mask"
    description: "Vector mask register containing mask style data."
returns:
  ctype: "typename Vec::register_type"
  description: "Integral value representing the vector mask register."
testing:
  - test_name: "full_mask"
    requires: ["to_array", "to_mask", "integral_all_true"]
    implementation: |
      using T = typename Vec::base_type;
      typename Vec::mask_type mask = to_mask<Vec>(integral_all_true<Vec>());
      auto vec = to_vector<Vec>(mask);

      testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), false};
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();

      storeu<Vec>(reference_result_ptr, inv<Vec>(set_zero<Vec>()));
      storeu<Vec>(test_result_ptr, vec);
      test_helper.synchronize();
      return test_helper.validate();
  - test_name: "no_mask"
    requires: ["to_mask", "integral_all_false", "storeu", "set_zero"]
    implementation: |
      using T = typename Vec::base_type;
      typename Vec::mask_type mask = to_mask<Vec>(integral_all_false<Vec>());
      auto vec = to_vector<Vec>(mask);

      testing::test_memory_helper_t<Vec> test_helper{Vec::vector_element_count(), false};
      auto reference_result_ptr = test_helper.result_ref();
      auto test_result_ptr = test_helper.result_target();

      storeu<Vec>(reference_result_ptr, set_zero<Vec>());
      storeu<Vec>(test_result_ptr, vec);
      test_helper.synchronize();
      return test_helper.validate();
definitions:
#INTEL - AVX512
  - target_extension: "avx512"
    ctype: ["int32_t", "uint32_t", "int64_t", "uint64_t"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_maskz_set1_epi{{ intrin_tp[ctype][1] }}( mask, -1 );"
  - target_extension: "avx512"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t"]
    lscpu_flags: ["avx512bw"]
    implementation: "return _mm512_maskz_set1_epi{{ intrin_tp[ctype][1] }}( mask, -1 );"
  - target_extension: "avx512"
    ctype: ["float"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_castsi512_ps(_mm512_maskz_set1_epi32(mask, -1));"
  - target_extension: "avx512"
    ctype: ["double"]
    lscpu_flags: ['avx512f']
    implementation: "return _mm512_castsi512_pd(_mm512_maskz_set1_epi64(mask, -1));"
#INTEL - AVX2
  - target_extension: "avx2"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['avx']
    implementation: "return mask; //mask is a vector already."
#INTEL - SSE
  - target_extension: "sse"
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ['sse2']
    implementation: "return mask; //mask is a vector already."
#ARM - NEON
  - target_extension: "neon"
    ctype: "int64_t"
    lscpu_flags: [ 'neon' ]
    implementation: "return vreinterpretq_s64_u64( mask ); //mask is a vector already."
#INTEL - FPGA
  - target_extension: ["oneAPIfpga", "oneAPIfpgaRTL"]
    ctype: ["int8_t", "uint8_t", "int16_t", "uint16_t", "int32_t", "uint32_t", "int64_t", "uint64_t", "float", "double"]
    lscpu_flags: ["oneAPIfpgaDev"]
    vector_length_agnostic: True
    implementation: "return mask;"
...